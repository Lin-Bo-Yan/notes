Q：
請幫我用正規表式的作法額外過濾掉 "—————  2023-04-11  —————" "wells  09:08"
另外，"wells"地方有可能是英文字 也有挳能是中文字，所以這部分改成只要是英文字或中文字都不能包含在內

A：
(?<=\n\n)(?![\p{L}\d]+\s+\d{2}:\d{2}|—+)\S+

這個正規表達式的說明：

(?<=\n\n)：正規表達式的開始，表示匹配前面是兩個換行符。
(?![\p{L}\d]+\s+\d{2}:\d{2}|—+)：使用負向先行斷言來排除不需要的部分。
[\p{L}\d]+\s+\d{2}:\d{2}：匹配由一或多個字母或數字，加上一個或多個空格，再加上兩個數字和一個冒號的格式。也就是「英文名字 + 時間」的格式。
|：或者。
—+：匹配由一或多個「—」符號組成的格式。
\S+：匹配一或多個非空格字符，也就是我們需要的對話文字。
使用這個正規表達式，即可過濾掉「————— 2023-04-11 —————」、「wells 09:08」以及「小紹 10:20」這三種格式。同時，英文名字或中文名字都不會被匹配到。

===========================================================================================================================
(?<=\n\n)(?!wells\s+\d{2}:\d{2}|—+)\S+

这个正则表达式的含义是：

(?<=\n\n)：前面必须是两个换行符 \n\n
(?!wells\s+\d{2}:\d{2}|—+)：后面不能是 wells 加上一个或多个空白符，再加上一个类似于时间格式的字符串，或者是一个或多个连续的 - 符号，这里使用了负向前瞻零宽断言
\S+：匹配一个或多个非空白字符

===========================================================================================================================

wells 和 華苓科技 在 WeChat 上的聊天記錄如下，請查收。\n\n—————  2023-04-11  —————\n\n\nwells  09:08\n\n早安\n\nwells  09:08\n\n哈囉\n\n\n\n

(?<=\n\n)：Positive Lookbehind，表示匹配前面是兩個換行符 \n\n。
[^\n]+：表示匹配不包含換行符的一或多個字符。


===========================================================================================================================
Pattern pattern = Pattern.compile("(?<=\\n\\n)(?![\\p{L}\\d]+\\s+\\d{2}:\\d{2}|—+)[^\\n]+");
Pattern pattern = Pattern.compile("(?<=\\n\\n)[^\\n]+");
Matcher matcher = pattern.matcher(text);


===========================================================================================================================

(?<=\n\n)[^\n]+

(?<=\n\n) 是一個正規表達式的先行斷言（lookbehind assertion），它表示匹配的位置需要在兩個換行符之後。
換行符\n表示文本中的換行符號。


[^\n]+ 是一個字符集，表示匹配除換行符\n之外的任意字符，使用 + 表示匹配一個或多個這樣的字符。

綜合起來，這個正規表達式的含義是匹配在兩個換行符之間的一行文字。
如果應用這個正規表達式到一段文字中，它將匹配並返回第一個在兩個換行符之間的非換行字符序列（一行文字）。
舉個例子，對於以下文字：

This is the first line.
This is the second line.
This is the third line.

應用正規表達式 (?<=\n\n)[^\n]+ 後，它將匹配到以下內容：
第一個匹配：This is the second line.



(?<=\n)\w+.*

這裡的解釋是：

(?<=\\n)：這是一個正向後瞻斷言，用來找出緊接在換行符（\n）後面的模式。
\\w+.*：這部分首先匹配一個或多個字母或數字（\\w+），然後匹配任意字元直到行尾（.*）。 這樣就可以符合類似 "test 2" 或 "test 3" 的文字。





===========================================================================================================================

(?<!\\S)\\[應用訊息: weixinfile\\(請在附件中查看\\)\\](?!\\S)
(?<=\n\n)(?!wells\s+\d{2}:\d{2}|—+)[^\n]+
(?<=\n\n)(?![\p{L}\d]+\s+\d{2}:\d{2}|—+)\S+

[圖片: 0115e90c9b7b8235056daf486d5f8833.jpg(請在附件中查看)]
[應用訊息: weixinfile(請在附件中查看)]

(\[.+?\])

===========================================================================================================================

^(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])[a-zA-Z0-9]{6,20}$
(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])[a-zA-Z0-9]{0,}$
.{6,}$

正規表達式 (?=.*[0-9]) 是一個正向先行斷言，它用於匹配包含至少一個數字的字串。
具體解釋如下：
(?=...) 是一個正向先行斷言的語法，表示在當前位置向後檢查，必須符合括號內的條件。
.*[0-9] 表示任意數量的字符（除換行符外），後面跟著至少一個數字。這部分的意思是匹配包含任意字符和至少一個數字的字串。
換句話說，(?=.*[0-9]) 用於確定當前位置之後的字串中至少包含一個數字。如果這個斷言為真，則整個正則表達式的匹配才會繼續進行。
在密碼驗證等情境中，可以使用這個斷言來確保密碼中包含至少一個數字的要求。

===========================================================================================================================

^[a-zA-Z0-9]+$
Pattern pattern = Pattern.compile("(?<=\\n\\n)[^\\n]+");
Matcher matcher = pattern.matcher(text);

matcher.find() && matcher.start()


這兩段程式是使用 Java 的正則表達式 (regular expression) 來尋找文本中特定的模式。
第一段程式碼創建了一個名為 pattern 的正則表達式物件。
第二段程式碼創建了一個 matcher 物件，它使用前面創建的 pattern 來在指定的 text 字符串上進行匹配操作。
接下來，您可以使用 matcher 物件的不同方法來執行各種操作，例如 find() 方法用於尋找下一個匹配，
group() 方法用於獲取當前匹配的字串，以及其他一些方法來獲取匹配的位置、數量等等。

範例：
public static void getUrl(String text) {
    Pattern pattern = Pattern.compile("^[a-zA-Z0-9]+$");
    Matcher matcher = pattern.matcher(text);
    if(matcher.find() && matcher.start() == 0){
        StringUtils.HaoLog("fff= "+"匹配成功！");
    } else {
        StringUtils.HaoLog("fff= "+"匹配失败！");
    }
}


===========================================================================================================================

阻擋網址有特殊符號：[^\s<>\"{}|\^`\[\]]

^(https?://.*[^/])$

^(https?://[^\s<>\"{}|\^`\[\]]*[^/])$


匹配以 "http" 或 "https" 開始，

後面跟著任何不是特定字符集（\s, <>, ", {}, |, ^, ```, [, ]）的字符序列，最後一個字符不是/的URL


[^\\p{IsFullwidth}]
===========================================================================================================================

我們想要提取第8個元素和第13個元素之間的文本

.{7}\s(.+?)\s.{12}


.{7} 匹配任何字符7次，表示跳過前7個字符（直到第8個字符）。
\\s 匹配空白字符（第8個字符）。
(.+?) 是一個捕獲組，匹配任何字符一次或多次，但以非貪婪方式進行（即盡可能少地匹配字符），這將捕獲我們感興趣的文本。
再次使用 \\s 匹配下一個空白字符（第13個字符）。
最後的 .{12} 是為了讓整個模式匹配整個字符串，但不會捕獲這些字符。


例如：
wells 和 華苓科技 在 WeChat 上的聊天記錄如下，請查收。

就會捕捉到 "華苓科技"

Pattern regularChar = Pattern.compile(".{7}\s(.+?)\s.{12}");
Matcher matcherChar = regularChar.matcher(text);
if (matcherChar.find()) {
    extractedChar = matcherChar.group(1);
}

===========================================================================================================================