FirebaseInstanceId 的 getInstance() 方法已經棄用了，他們的功能是獲取註冊令牌，
用FirebaseMessagingService 呼叫public void onNewToken(String token) 方法不也是得到令牌嗎，
這兩個方法，FirebaseMessagingService比較好對吧



是的，您說的沒錯。FirebaseInstanceId.getInstance() 已被棄用，現在應該使用FirebaseMessaging.getInstance().getToken()或
FirebaseMessagingService的onNewToken()方法來獲取註冊令牌。
FirebaseMessagingService的onNewToken()方法是Firebase在推送令牌更新時自動調用的方法，
您可以重寫這個方法來處理註冊令牌更新的邏輯，而無需顯式調用FirebaseInstanceId的方法。這樣更簡潔，更符合最新的Firebase推送標準。

sdk.dir=C\:\\Users\\boyan.lin\\AppData\\Local\\Android\\Sdk

Warning: This version only understands SDK XML versions up to 2 but an SDK XML file of version 3 was encountered. This can happen if you use versions of Android Studio and the command-line tools that were released at different times.
這個警告通常表示 Android Studio 和命令行工具版本不兼容，建議升級 Android Studio 和命令行工具至最新版本以解決此問題。

你可以打開 Android Studio，並從菜單中選擇 File -> Settings -> Appearance & Behavior -> System Settings -> Android SDK。
在這裡，你可以看到當前的 Android SDK 版本以及可用的更新。請確認你的 Android SDK 已經更新到最新版本，然後重新運行項目，應該可以避免這個警告。


發現專案build不起來是因為連接不到虛擬機，有可能是因為React Native init所建置的專案和android gradle版本不一致，所以雙方沒辦法連接
嘗試過連接實體手機也是無法連接。
Adb reverse tcp not working on android connected remotely
https://stackoverflow.com/questions/46138780/adb-reverse-tcp-not-working-on-android-connected-remotely

react-native解决installDebug問題
https://blog.csdn.net/qq_32192725/article/details/87967508?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-87967508-blog-75779929.pc_relevant_3mothn_strategy_and_data_recovery&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-87967508-blog-75779929.pc_relevant_3mothn_strategy_and_data_recovery&utm_relevant_index=4

找到一個解法是用android studio 開啟React Native專案，IDE會把gradle版本自動更新到符合的版本，這個方法在新專案是可行的，在jitsi-meet專案又有問題。


超詳細React Native環境搭建以及運行項目（Windows環境）
https://blog.csdn.net/ljx1048900106/article/details/108282012#:~:text=%E7%8E%B0%E5%9C%A8%E4%BD%A0%E5%8F%AF%E4%BB%A5%E8%BF%90%E8%A1%8Creact-native%20run-android%E6%9D%A5%E5%9C%A8%E8%AE%BE%E5%A4%87%E4%B8%8A%E5%AE%89%E8%A3%85%E5%B9%B6%E5%90%AF%E5%8A%A8%E5%BA%94%E7%94%A8%E4%BA%86%E3%80%82%20%24%20react-native%20run-android,%E6%88%96%E8%80%85%20%24%20yarn%20android%202.


https://benjaminnl.pixnet.net/blog/post/53362765-windows%E7%92%B0%E5%A2%83%E4%BD%BF%E7%94%A8linux%E7%9A%84make%E6%8C%87%E4%BB%A4


implementation fileTree(dir: 'libs', include: ['*.jar'])
implementation 'androidx.appcompat:appcompat:1.4.1'
implementation 'androidx.constraintlayout:constraintlayout:2.1.3'

這是在 Android 應用程式的 build.gradle 文件中設置的 dependencies，用於添加所需的 Android 庫。具體而言：

fileTree(dir: 'libs', include: ['*.jar'])：將 libs 目錄下的所有 jar 文件添加到項目中。
implementation 'androidx.appcompat:appcompat:1.4.1'：添加 AndroidX 库中的 AppCompat 库，這是一個向後兼容的庫，可確保應用程式在不同版本的 Android 上運行一致。
implementation 'androidx.constraintlayout:constraintlayout:2.1.3'：添加 ConstraintLayout 庫，這是一個用於設計 Android 用戶界面的庫。

公司建立的jitsi server：
https://laledev0.flowring.com/

onConsoleMessage= 

command= 
downloadByUrl 個人聊天室 -> 下載圖片
webOk 登入後呼叫
Logout  設定 -> 登出
getAPPVersion 設定 -> 關於Lale
feedback 設定 -> 回報
openQRcode 聊天 -> QRcode
openWebView 個人聊天室 -> 點擊對方傳的url
openPhoneWebView 個人猜測，判斷是開啟https://meet.jit.si/ 時呼叫
updateRooms 創建群組時呼叫
share 在加好友的那邊 特殊加好友 寄信和簡訊，QRcode那邊的分享圖片


NewUrl
openChrome 
getAddressBook
newLinkApp
downloadByBytesBase64 -> 測試用
tokenRefresh 告訴app端刷新token
setRoomBackground
updateUser
unDo



inKeyguardRestrictedInputMode()
該方法用於判斷當前的鎖屏狀態是否為受限輸入模式
受限輸入模式是指當使用者設定了鎖屏密碼、PIN 碼、圖案等方式時，系統會在鎖屏時啟用一種保護機制
滑動螢幕非密碼鎖也會判斷上鎖



isKeyguardSecure()
跟 inKeyguardRestrictedInputMode 差別在拿掉 滑動螢幕非密碼鎖會判定螢幕沒有上鎖
不過滑掉app server 會判定沒在運作



isKeyguardLocked()
已鎖定的鎖屏狀態是指系統在使用者按下電源鍵後，系統會啟動一個鎖屏畫面，使用者必須進行解鎖操作才能進入系統。
功能跟 inKeyguardRestrictedInputMode 一樣

jitsi-meet 錯誤訊息：
CreateProcess error=193, %1 不是有效的 Win32 應用程式。



AR 假資料

//                    val lightId = LightID(
//                        status = 1,
//                        coordinateX = 0.41749913f,
//                        coordinateY = 0.4111436f,
//                        isDetected = true,
//                        deviceId = 123456789L,
//                        detectionTime = 3094,
//                        decodedTime = 206,
//                        isReady = true,
//                        rotation = Vector3(0.56f, -0.20f, -0.13f),
//                        translation = Vector3(-0.06f, -0.23f, 0.66f),
//                        position = Vector3(-0.07f, -0.16f, 0.67f)
//                    )



webView在android5.0之後會自動設置同步功能，意思是說網頁瀏覽器的cookie狀態會直接跟app同步，確保webView和瀏覽器之間共享cookie
如果沒有同步功能，那麼webView和瀏覽器之間就會有不同步衍伸的問題，例如說：webView 設置cookie，在瀏覽器並未同步，那麼訪問同一個網站時就會無法識別用戶


=========================================

API 19以上WebView緩存目錄
Android4.4+當在項目中使用了WebView時，會在/data/data/package_name/目錄下生成一個app_webview文件夾(緩存索引)
也會有一個cache文件夾(對應文件)

不重要!!
Android4.4以下存放在/data/data/package_name/databases(緩存索引)和/data/data/package_name/cache/webviewCacheChromunm(對應文件)


webView的緩存模式：
LOAD_CACHE_ONLY: 不使用網絡，只讀取本地緩存數據
LOAD_DEFAULT: 根據cache-control決定是否從網絡上取數據。
LOAD_CACHE_NORMAL: API level 17中已經廢棄, 從API level 11開始作用同LOAD_DEFAULT模式
LOAD_NO_CACHE: 不使用緩存，只從網絡獲取數據.
LOAD_CACHE_ELSE_NETWORK，只要本地有，無論是否過期，或者no-cache，都使用緩存中的數據。

==================================================================================

3/31 下班前把android 送審，確認nic 資料更新了沒，4/10 號上架完成，
所以連假完有2天時間要注意送審結果，如果有問題需在兩天處理完成。

==================================================================================

點擊之後拿到fileId，url，如果沒有就去找他的暫存檔案位置，如果暫存位置也沒了，那就不讓他開。
  
單一下點擊事件觸發預覽，如果server的檔案30天後過期，那就去實體檔，如果連實體檔都沒有就是判定檔按過期
下載佔存檔先判斷名稱是否存在，這段邏輯設計成跟download共用，加入列舉設計，然後將開啟檔案下載的動作切開寫成獨立class
方便閱讀，還須多一層邏輯是如果server的檔案過期，要去實體找檔案

==================================================================================


https://play.google.com/console/u/0/developers/7401254602311634155/app/4973311250219533869/app-dashboard?timespan=thirtyDays

urlWebView.loadUrl("http://docs.google.com/gview?embedded=true&url="+"YOUR_DOC_URL_HERE");


/storage/emulated/0/Pictures/Lale/openfile/lale activity整理.xlsx
/storage/emulated/0/Pictures/Lale/openfile/未命名簡報.pptx

Pictures/Lale/openfile/Lale/openfile/未命名簡報.pptx

http://docs.google.com/gview?embedded=true&url=laledev0.flowring.com/fileserver/file/download/7ef4ce7efc3848f495aa9c2adaf70a11
https://laledev0.flowring.com/fileserver/file/download/7ef4ce7efc3848f495aa9c2adaf70a11

Environment.DIRECTORY_PICTURES + File.separator + app_name + File.separator + "openfile";


==================================================================================
https://news.lale.im -> 這是快報的domain

原本 lale server 因為是測試，url 會是這個：https://laledev0.flowring.com/laleweb
原本 webview 因為是測試，url 會是這個：https://laletest.flowring.com/WebAgenda/eimApp/index.html#

現在更改為：
lale server：https://laleserver.lale.im/laleweb
webview：https://laleserver.lale.im/imApp/index.html#


==================================================================================


開jira，把驗證版本的功能放上去，送QA測
https://qms.flowring.com:8080/browse/LAC-584
https://portal.flowring.com/WebAgenda/MIS/HotFixInsert.jsp

1056
該功能需要相機權限
onShowFileChooser

createVoideFile()
==================================================================================

shareFileToCloud(JSONObject data)
multipleShareToWeb(Intent intent)

jsp postMessage:


int hashCode = fileName.hashCode();
jsonObject.put("onlyKey",String.valueOf(hashCode));

StringUtils.HaoLog("文字= "+jsonObject);
StringUtils.HaoLog("joe= "+matcher.group());



==================================================================================

這是 Base64.encodeToString 方法的簽名，其中各個參數的意義如下：

input：要進行編碼的原始數據的字節數组。
offset：input 中要開始編碼的位置（偏移量）。
len：要編碼的字節數
flags：指定編碼時要使用的選項。可以是 DEFAULT、NO_WRAP、URL_SAFE 或 NO_PADDING。
Base64.encodeToString 方法將指定的數據編碼為 Base64 字符串，然後返回編碼後的字符串。

saveImage(fileName,getBase64FromPath(outputFile))

ExternalServerSetting
https://laletest.flowring.com/SaaSServerCall
String urlEnd = new ExternalServerSetting().call_service_url + "/#/call/" + roomSecret + "/" + dataEncode;

對於通話，我們會建立一個url給jitsi 建立通話房間
roomIdParse，msgIdParse，roomSecret，將以上資訊帶入 url 中開啟通話服務

 
當拿不到 call_service_url 時會給預設的，既不是打api拿到

甚麼時候會造成call_service_url 空值?
UserControlCenter.getUserMinInfo().externalServerSetting.call_service_url.isEmpty()

所以建立通話時候是用 預是的url 以roomIdParse，msgIdParse，roomSecret 組出新uri
然後給web

聊天室傳過來會攜帶roomid
道觀通知會收到一長串json


道觀通知不會攜帶roomid
聊天室傳過來會攜帶roomid

系統才不管你是哪種通知，反正通知超過4則系統就會收合
這時候mainActivity收roomid就會是null

==================================================================================

自定義推播會有

{
    "title":"系統通知",
    "body":"您已在其他裝置登入，此裝置已自動登出",
    "userID":userID,
    "serverURL":serverURL
}

================================================================================================


is_lale_message_received()方法：
如果 等於lale.message.received 回傳true，
MessageInfo.getText() lale.message.received 為true
回傳JSONObject(content).optString("msg");


RoomMinInfo class裡面包含 "群組" ，個人1對1 (目前看起來)
群組 room.type = 6
個人1對1 room.type = 1


RoomMinInfo：
room_1658393321464266752     room.id
測試群組                      room.name
6                            room.type
李燕萍加入群組                room.last_msg
1684228988818                room.last_msg_time
0                            room.unread_count
group_1658393321464266753    room.groupId
                              room.avatarUrl
                              room.groupAdmin
0                            room.topTime
true                         room.isNotification
1                            room.status
0                            room.call_status

================================================================================================
ToC：
git cherry-pick
git cherry-pick --continue

單一裝置登入處理，配合server 一起調整測試：
ea1ebd4
0742882
65bc0bb
33fe7b4
34e5521
0ec3bd5
c2a47a8
ad364a7
bfe2b5a


c27cd49
480fa3a
abff42e
f263430
3318d27
8427f60

feat: 群內成員收到推播顯示：
c152627
803679f
c34f07c
a19db19


b7a4b0d   style:一些變數整理
3685ae1   style:新增Log
4671edb   setPusher ，新增欄位：額外自訂義推送資訊
8c4c1aa   登出失敗關閉Pusher
9d57014   權限結構優化
5557551   修改伺服器錯誤後的處理流程


void shareToWeb(Intent intent)

================================================================================================
華苓科技 (公佈欄管理者 : 莊千慧;莊昀霓;劉沛榆) (板主 : 莊千慧)

================================================================================================


修復錯誤的 OpenSSL 版本
OpenSSL 1.1.1d in lib/x86/libsqlcipher.so

unzip -p Yourapp.apk | strings | grep "OpenSSL"

================================================================================================
訊息回收會走MQTT
updateMsg


這牽扯到一個問題是 這邊的設計是
這邊檢查辦公維護是透過app打api 去問server的
目前是
1.開啟app時 執行/ann/in-range/{given_time}
2.到達開始維護時間  執行/ann/in-range/{given_time}
3.api 503   執行/ann/in-range/{given_time}

我剛問brice 如果是有lale的那種打api 是會透過webMessage 把api error 告訴app端
但是純辦公版本打 af的api 出錯是不會告訴app的
也就是說 純辦公版本在即時通知使用者辦公維護這點應該是會出問題


你是不是忘了已經改成長token了? 我前幾天應該有跟你們說過
機制我已經改了，現在如果是行動裝置的token我會給 long-live的token ，除非是沒有紀錄行動裝置登入的token才是走原本機制
如果你要測試原本的行為應該在dev10 tob的環境測試
toc tob 取得 token 時效性已根據登入的裝置有所不同，目前dev0我已上版此功能


================================================================================================


QRcode info那隻api 很慢
然後第三方簡易登入失敗

https://agentflow.flowring.com:8443/WebAgenda    /api/dau/EIM/qrcode/info
https://portal.flowring.com/WebAgenda            /api/dau/EIM/qrcode/info


================================================================================================

    public static void setAnnouncementServer(String announceServer) {
        SharedPreferences pref = PreferenceManager.getDefaultSharedPreferences(context);
        pref.edit().putString("AnnounceServer",announceServer).apply();
        AnnounceServer = announceServer;
    }


    這邊在set的時候是null
    所以取值時會出錯

碼農日常-『Android studio』螢幕截圖Screen Shot實作
https://thumbb13555.pixnet.net/blog/post/331207995-screenshot

FileProvider 第三方應用開啟 (example: open pdf)
https://hackmd.io/@fd-javaAndroid/SyTn1b0FK


浮水印位置：畫面哪個位置
浮水印內容：用戶名，日期，編號?(無法取得員工編號)





PDFView:
implementation 'com.github.barteksc:android-pdf-viewer:3.2.0-beta.1'

AndroidPdfViewer
implementation 'com.joanzapata.pdfview:android-pdfview:1.0.4@aar'

PdfRenderer



開啟PDF：
https://github.com/groupdocs-watermark/GroupDocs.Watermark-for-Java/tree/master/Examples

https://gist.github.com/aspose-com-gists/b5f7f2262b678f17cf0d7b1e318d092e

https://github.com/thebabush/pdf-strip-watermark/blob/master/src/main/java/it/fuck/kenoph/Main.java

https://github.com/LibrePDF/OpenPDF/blob/master/pdf-toolbox/src/test/java/com/lowagie/examples/general/copystamp/AddWatermarkPageNumbers.java

https://github.com/qmetric/pdf-manipulation/blob/master/src/main/java/com/qmetric/pdf/manipulation/pdfbox/PdfBoxWatermark.java




使用Android打印框架自定義文檔：Android提供了打印框架，您可以通過創建打印適配器（Print Adapter）來自定義文檔。您可以在打印適配器的onWrite()方法中渲染頁面並將它們寫入PDF文件。詳細資訊和代碼示例可以參考Android開發者文檔中的"打印自定義文檔"（https://developer.android.google.cn/training/printing/custom-docs?hl=zh-cn）。
使用MuPdf庫：MuPdf是一個輕量級且功能豐富的PDF處理庫，它可以用於在Android應用程序中讀取和標註PDF文件。您可以下載MuPdf的源代碼，並將其集成到您的應用程序中。有關詳細信息和示例代碼，您可以參考"Android App集成MuPdf，實現Pdf閱讀、編輯、標記等功能"（http://www.longluo.me/blog/2021/08/01/Android-Pdf-Viewer/）。
使用AndroidPdfViewer庫：AndroidPdfViewer是一個Java實現的Android PDF查看器庫，您可以使用它在應用程序中顯示和查看PDF文件。您可以在PDF查看器的佈局中使用FrameLayout覆蓋自定義的WaterMarkView，該視圖負責在畫布上生成和繪製浮水印文字。這種方法不會將浮水印嵌入到PDF文件本身，而是在渲染時動態添加浮水印。有關詳細信息和代碼示例，您可以參考"CSDN博客中的android PDFview加載PDF&PDF加水印"（https://blog.csdn.net/qq_36488374/article/details/88187474）。
使用"android-pdfview"庫：這是一個用於實現PDF查看功能的庫。它包括PDF閱讀、目錄導航、縮略圖導航等功能。該庫的示例代碼和佈局文件可以在"Android原生PDF功能實現"（https://www.cnblogs.com/qixingchao/p/11658226.html）中找到。該文章還提到了實現PDF預覽縮略圖的方法和相關類。
使用PdfRenderer類：PdfRenderer是Android 5.0（API級別21）引入的一個類，用於渲染和顯示PDF文件。您可以使用PdfRenderer將PDF頁面渲染到Bitmap上，然後在應用程序中顯示。這種方法對於基本的PDF查看功能來說是適合的。有關不同方法的詳細比較和代碼示例，可以參考"android:加載PDF幾種方法匯總對比"（https://www.jianshu.com/p/f68e1087ea36）。
希望這些資訊對您有所幫助！如果您有其他問題，請隨時提問。


LEP-148
mupdf-android-viewer


Android App集成MuPdf，實現Pdf閱讀、編輯、標記等功能
http://www.longluo.me/blog/2021/08/01/Android-Pdf-Viewer/
https://github.com/ArtifexSoftware/mupdf-android-viewer.git
git://git.ghostscript.com/mupdf-android-viewer.git

https://github.com/longluo/DroidPdf.git
https://www.mupdf.com/releases/index.html



https://github.com/PSPDFKit/pspdfkit-android-catalog
https://github.com/PSPDFKit/pspdfkit-android-simple-example
https://github.com/YemreCenan/-Creating-Pdf-file-with-itext7.git
git clone --recursive 


我的個人資訊api
/api/dau/personalData
錯誤狀態碼= 400

AF 環境是.9.53




String fileName = "webViewVersion.txt";
String filePath = getCacheDir().getAbsolutePath() + File.separator + fileName;
File file = new File(filePath);
String oldVersion = FileUtils.readTextFromFile(file);
StringUtils.HaoLog("fff= "+oldVersion);






fly
jerry
Him25121919



LEP-161 App 跳出更新版本，點擊後會跳到 Lale，不是 Lale企業







