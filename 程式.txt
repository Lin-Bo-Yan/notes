用廣播做監聽器
    
==================================================================================   
        DownloadManager downloadManager = (DownloadManager) getSystemService(DOWNLOAD_SERVICE);
        downloadManager.enqueue(request);
        long Id = downloadManager.enqueue(request);
        listener(Id,data);


          private BroadcastReceiver broadcastReceiver;
    private void listener(final long Id,JSONObject data) {
        // 註冊廣播監聽系統的下載完成事件。
        IntentFilter intentFilter = new IntentFilter(DownloadManager.ACTION_DOWNLOAD_COMPLETE);
        broadcastReceiver = new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                long ID = intent.getLongExtra(DownloadManager.EXTRA_DOWNLOAD_ID, -1);
                if (ID == Id) {
                    StringUtils.HaoLog("dd= "+"完成");
                    shareFileType(data);
                }
            }
        };
        registerReceiver(broadcastReceiver, intentFilter);
    }  

==================================================================================

 File myFilePath = new File(Environment.getExternalStorageDirectory() + "/DB_BACK");
            if (!myFilePath.exists()) {
                myFilePath.mkdir();
            }

            File fileRestore = new File(Environment.getExternalStorageDirectory() + "/DB_BACK/DB_BACK_POS" + ".db");
            if (fileRestore.exists()) {
                InputStream in = new FileInputStream(fileRestore);
                SQLiteDatabase db = getReadableDatabase();
//                SQLite sqLite = new SQLite(context);
//                SQLiteDatabase db = sqLite.getReadableDatabase();
                FileOutputStream fw = new FileOutputStream(new File(db.getPath()));
                db.close();
//                sqLite.close();

                byte data[] = new byte[in.available()];
                in.read(data, 0, in.available());
                fw.write(data);

                fw.close();
                in.close();

                fileRestore.delete();
                }
==================================================================================
存到內存

   String fileName = "ONLINE.csv";
            File fileRestore = new File(Environment.getExternalStorageDirectory() + File.separator + "DB_BACK" + File.separator + fileName)
==================================================================================

private void UploadCompression(){
        String fileName = "DB_BACK_ORDER.db";
        File backupFile = new File(Environment.getExternalStorageDirectory() + File.separator + "DB_BACK" + File.separator + fileName);
        File zipFile = new File(Environment.getExternalStorageDirectory()+File.separator+"DB_BACK"+File.separator +"DB_BACK_ORDER.zip");
        try{
            InputStream input = new FileInputStream(backupFile);
            ZipOutputStream zipOut = null;
            zipOut = new ZipOutputStream(new FileOutputStream(zipFile));
            zipOut.putNextEntry(new ZipEntry(backupFile.getName()));
            int temp = 0;
            while((temp = input.read())!=-1){
                zipOut.write(temp);
            }
            input.close();
            zipOut.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }

==================================================================================

        File folder = new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES), fileName);
        if (!folder.exists()) {
            folder.mkdirs(); // 創建子目錄
        }
        File file = new File(folder, fileName);
        request.setDestinationUri(Uri.fromFile(file));
==================================================================================
event id = onlyKey
[
  {
    "onlyKey": "event_1636913865210068992",
    "name": "20210811_194151.jpg",
    "url": "https://laledev0.flowring.com/fileserver/file/download/9a35af5787ad4766a48df375aa8a0321"
  }
]
event_163691
==================================================================================

讀取目錄底下的檔案名稱
File download = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS);
                if(download.exists()) {
                    File[] files = download.listFiles();
                    for (File file : files) {
                        if (file.isFile()) {
                            String fileName = file.getName();
                            StringUtils.HaoLog("dd= fileName " + fileName);
                        }
                    }
                }
==================================================================================
    public static final String ACTION_DOWNLOAD_COMPLETE = "android.intent.action.DOWNLOAD_COMPLETE";
    public static final String ACTION_NOTIFICATION_CLICKED = "android.intent.action.DOWNLOAD_NOTIFICATION_CLICKED";
    public static final String ACTION_VIEW_DOWNLOADS = "android.intent.action.VIEW_DOWNLOADS";
    public static final String COLUMN_BYTES_DOWNLOADED_SO_FAR = "bytes_so_far";
    public static final String COLUMN_DESCRIPTION = "description";
    public static final String COLUMN_ID = "_id";
    public static final String COLUMN_LAST_MODIFIED_TIMESTAMP = "last_modified_timestamp";


這些是 Android 下載管理器 (Download Manager) 類別中所使用的常數，具體說明如下：

ACTION_DOWNLOAD_COMPLETE：下載完成廣播 (broadcast) 的動作名稱。
ACTION_NOTIFICATION_CLICKED：點擊下載通知欄位 (notification) 的廣播動作名稱。
ACTION_VIEW_DOWNLOADS：顯示下載清單的活動 (activity) 的動作名稱。
COLUMN_BYTES_DOWNLOADED_SO_FAR：用於表示已經下載的資料大小的欄位名稱。
COLUMN_DESCRIPTION：用於表示下載描述 (description) 的欄位名稱。
COLUMN_ID：用於表示下載 ID 的欄位名稱。
COLUMN_LAST_MODIFIED_TIMESTAMP：用於表示下載檔案最後修改時間的欄位名稱。
這些常數可以在程式中用來註冊下載完成廣播接收器、建立下載通知欄位、顯示下載清單等等操作。
例如，當下載完成後，可以透過註冊 ACTION_DOWNLOAD_COMPLETE 廣播接收器來接收下載完成通知，
並在接收到通知後進行相應的處理；或者在進行下載時，可以使用 COLUMN_DESCRIPTION 欄位來設定下載描述，
然後在建立下載通知欄位時顯示相應的描述資訊。

==================================================================================

Thread.currentThread().getName() 看到現在的 Thread 名稱
==================================================================================

public class ReadExcelFile {
    public static void main(String[] args) throws IOException {
        File file = new File("example.xlsx");
        FileInputStream inputStream = new FileInputStream(file);
        Workbook workbook = WorkbookFactory.create(inputStream);
        Sheet sheet = workbook.getSheetAt(0);
        for (Row row : sheet) {
            for (Cell cell : row) {
                System.out.print(cell.toString() + "\t");
            }
            System.out.println();
        }
        workbook.close();
        inputStream.close();
    }
}

==================================================================================
URLConnection 可以得到檔案類型
connection.getContentType()

//URLConnection connection;
//try{
//    connection = new URL(uri).openConnection();
//}catch (IOException e){
//  StringUtils.HaoLog("cacheShareFileType connectionError=" + e);
//  return;
//}
//final SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH mm ss SSS");
//String fileName = oldFileName == null ? sdf.format(new Date().getDate()) + FileUtils.toExtension(connection.getContentType()) : oldFileName;


==================================================================================
    private BroadcastReceiver broadcastReceiver;
    private void listener(final long Id, String fileName, String tableOfContents) {
        // 註冊廣播監聽系統的下載完成事件。
        IntentFilter intentFilter = new IntentFilter(DownloadManager.ACTION_DOWNLOAD_COMPLETE);
        broadcastReceiver = new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                long ID = intent.getLongExtra(DownloadManager.EXTRA_DOWNLOAD_ID, -1);
                if (ID == Id) {
                    StringUtils.HaoLog("分享檔案下載動作完成");
                    shareFileType(fileName,tableOfContents);
                }
            }
        };
        registerReceiver(broadcastReceiver, intentFilter);
    }
==================================================================================


// 創建一個File對象，代表Excel檔案
File file = new File("path/to/excel/file.xlsx");

// 創建一個FileInputStream對象，用於讀取Excel檔案
FileInputStream inputStream = new FileInputStream(file);

// 創建一個XSSFWorkbook對象，代表整個Excel檔案
XSSFWorkbook workbook = new XSSFWorkbook(inputStream);

// 獲取第一個工作表
XSSFSheet sheet = workbook.getSheetAt(0);

// 獲取第一行
XSSFRow row = sheet.getRow(0);

// 獲取第一列
XSSFCell cell = row.getCell(0);

// 讀取單元格中的值
String value = cell.getStringCellValue();

// 關閉工作簿和流
workbook.close();
inputStream.close();

==================================================================================
 // 開啟Excel文件
        FileInputStream inputStream = new FileInputStream(new File("example.xlsx"));

        // 建立工作簿對象
        Workbook workbook = new XSSFWorkbook(inputStream);

        // 選擇要操作的工作表
        Sheet sheet = workbook.getSheetAt(0);

        // 遍歷所有行
        for (Row row : sheet) {

            // 遍歷所有列
            for (Cell cell : row) {

                // 判斷單元格類型
                switch (cell.getCellType()) {
                    case STRING:
                        System.out.print(cell.getStringCellValue() + "\t");
                        break;
                    case NUMERIC:
                        System.out.print(cell.getNumericCellValue() + "\t");
                        break;
                    case BOOLEAN:
                        System.out.print(cell.getBooleanCellValue() + "\t");
                        break;
                    default:
                        System.out.print("\t");
                }
            }
            System.out.println();
        }

        // 關閉工作簿和輸入流
        workbook.close();
        inputStream.close();
 ==================================================================================
Handler 切換執行續
         if(folder.exists()){
            StringUtils.HaoLog("檔案存在");
            new Handler(Looper.getMainLooper()).post(() -> {
                MainWebActivity.categoryFileType(folder);
            });
            //執行開檔
        }
 ==================================================================================

  public ArrayList<ExcelBean> getExcelData(String xlsName, int index) {
    ArrayList<ExcelBean> list = new ArrayList<>();
    //获取文件管理器
    AssetManager manager = context.getAssets();
    try {
      Workbook workbook = Workbook.getWorkbook(manager.open(xlsName));
      Sheet sheet = workbook.getSheet(index);
      //表格一共有多少行
      int sheetRows = sheet.getRows();
      //将数据添加到集合中
      for (int i = 0; i < sheetRows; i++) {
        ExcelBean bean = new ExcelBean();
        //获取列的数据
        bean.setChinese(sheet.getCell(0, i).getContents());
        bean.setEnglish(sheet.getCell(1, i).getContents());
        bean.setSpell(sheet.getCell(2, i).getContents());
        list.add(bean);
      }
      workbook.close();
    } catch (Exception e) {
      e.printStackTrace();
    }
    return list;
  }

==================================================================================

檢查版本

public boolean checkAppNeedUpdate() {
        Request.Builder request = new Request.Builder()
                .url(AllData.getMainServer() + "/util/app/version/android")
                .get()
                .addHeader("Content-Type", "application/json");
        HttpReturn httpReturn = gethttpReturn(request);
        String data = new Gson().toJson(httpReturn.data);
        GetMinVersion dbVersion = new Gson().fromJson(data,GetMinVersion.class);
        String appVersion = MainWebActivity.getVersionName(AllData.context);

        if(dbVersion != null && dbVersion.version != null && !dbVersion.version.isEmpty()
        && appVersion != null && !appVersion.isEmpty()){
            Boolean newVersion = appVersion.equals(dbVersion.version);
            if(newVersion){
                return false;
            } else {
                return true;
            }
        }else {
            StringUtils.HaoLog("googleVersion 為 null");
            return false;
        }
    }



    public void checkAppNeedUpdate() {
        new Thread(() -> {
            if (CloudUtils.iCloudUtils.checkAppNeedUpdate())
                runOnUiThread(() -> {
                    showUpgradeDialog();
                });
        }).start();
    }

new AlertDialog.Builder((Context) this)


public class GetMinVersion {
    public String osName = null;
    public String version = null;
}

获取软件版本号，对应AndroidManifest.xml下android:versionName
獲取軟件版本號，對應AndroidManifest.xml下android:versionName
==================================================================================
H5喚起android app，啟動關聯應用，在MAIN下面設定

    <intent-filter android:autoVerify="true">
        <action android:name="android.intent.action.VIEW" />
        <category android:name="android.intent.category.DEFAULT" />
        <category android:name="android.intent.category.BROWSABLE" />
        <data android:scheme="laletoc"/>
    </intent-filter>
https://blog.csdn.net/YukimineRyuu/article/details/106063792
https://juejin.cn/post/7097784616961966094

<intent-filter>
    <action android:name="android.intent.action.SEND" />
    <category android:name="android.intent.category.DEFAULT" />
    <data android:mimeType="*/*" />
</intent-filter>

==================================================================================

Intent intent = new Intent(AllData.context, MainWebActivity.class);
intent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);// 將啟動模式設置為 FLAG_ACTIVITY_SINGLE_TOP
intent.setType(getIntent().getType()); // 設置 Intent 的類型為從接收到的 Intent 中獲取的類型。

Uri uri = getIntent().getParcelableExtra(Intent.EXTRA_STREAM);
String extraText = getIntent().getStringExtra(Intent.EXTRA_TEXT);
if (uri != null){ //從接收到的 Intent 中獲取圖片的 Uri 和文字描述，如果有圖片，就將接收到的 Intent 的所有額外訊息攜帶到新的 Intent 中。
    intent.putExtras(getIntent());
}
intent.putExtra(Intent.EXTRA_TEXT, extraText);//將文字描述放入 Intent 的額外訊息中。
intent.setAction(getIntent().getAction()); // android.intent.action.SEND
// 將原始 Intent 的操作設置為新的 Intent 的操作。
{
    Intent intent1 = new Intent(getIntent().getAction());
    intent1.setAction(getIntent().getAction());
    if (uri != null){
        intent1.putExtras(getIntent());
    }
    intent1.putExtra(Intent.EXTRA_TEXT, extraText);
    LocalBroadcastManager.getInstance(this).sendBroadcast(intent1); //發送廣播訊息
}
startActivity(intent);
finish();

==================================================================================
加上監聽器類型，廣播接收器才會接收到設置setType，預設是沒有接收類型
try {
    itFilter.addDataType("*/*");
}catch (IntentFilter.MalformedMimeTypeException e){
    StringUtils.HaoLog( e.toString());
    e.printStackTrace();
}

==================================================================================
接受分享多選的動作，接受到之後用陣列裝資料

ArrayList<Uri> uris = getIntent().getParcelableArrayListExtra(Intent.EXTRA_STREAM);
        if (uris != null){
            //intent1.putExtras(getIntent());
            for(Uri uri : uris){
                StringUtils.HaoLog("BroadcastReceiver=" +" 2 "+ uri);
            }
         }

==================================================================================
接受分享多選的動作：這種處理方法不適合微信，因為微信多選分享檔案是壓縮成ZIP，所以ClipData會是null，在來
會取不到URI和type，所以未來如果line可以多選分享說不定能用上

        ClipData clipData = getIntent().getClipData();
        if (clipData != null) {
            // 處理多個共享的內容
            for (int i = 0; i < clipData.getItemCount(); i++) {
                Uri ClipDataUri = clipData.getItemAt(i).getUri();
                StringUtils.HaoLog("dd= "+ClipDataUri);
                // 處理共享的內容，例如保存到本地文件或在應用中顯示

                ClipData.Item item = clipData.getItemAt(i);
                String type = getContentResolver().getType(item.getUri());
                //取得檔案type
            }
        } else {
            Intent intent1 = new Intent(getIntent().getAction());
            intent1.setAction(getIntent().getAction());
            intent1.setType(getIntent().getType());
            if (uri != null){
                intent1.putExtras(getIntent());
            }
            intent1.putExtra(Intent.EXTRA_TEXT, extraText);
            LocalBroadcastManager.getInstance(this).sendBroadcast(intent1); //發送廣播訊息
        }
==================================================================================

private void gotoShare(){
    try {
        JSONArray jsonArray = new JSONArray();
        JSONObject jsonObject = new JSONObject();
        jsonObject.put("mimeType", "message");
        jsonObject.put("string", "www.google.com");
        jsonArray.put(jsonObject);
        sendToWeb(new JSONObject().put("type","gotoShare").put("data",jsonArray).toString());
    } catch (JSONException e) {
        e.printStackTrace();
    }
}

==================================================================================

//創建照片路徑，getCacheDir()取得內部Cache路徑
private File createImageFile() throws IOException {
    String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date());
    String imageFileName = "JPEG_" + timeStamp + ".jpg";
    File image = new File(getCacheDir(), imageFileName);
    currentPhotoPath = image.getAbsolutePath();
    return image;
}

==================================================================================
改寫方法：
    public String getBase64FromPath(Uri uri) {
        String base64 = "";
        try {
            InputStream inputStream = getContentResolver().openInputStream(uri);
            byte[] buffer = new byte[inputStream.available() + 100];
            int length = inputStream.read(buffer);
            base64 = Base64.encodeToString(buffer, 0, length, Base64.DEFAULT);
            inputStream.close();
        } catch (IOException e) {
            StringUtils.HaoLog("錯誤訊息"+e);
            e.printStackTrace();
        }
        return base64;
    }

==================================================================================
    String thumbnail = getBase64FromPath(imageUri);
    try {
        JSONArray jsonArray = new JSONArray();
        JSONObject jsonObject = new JSONObject();
        jsonObject.put("onlyKey","hashcode");
        jsonObject.put("mimeType",type);
        jsonObject.put("name",fileName);
        jsonObject.put("thumbnail",thumbnail);
        jsonArray.put(jsonObject);
        sendToWeb(new JSONObject().put("type","gotoShare").put("data",jsonArray).toString());
    } catch (JSONException e) {
        e.printStackTrace();
    }
==================================================================================
縮圖：

    public static File bitmapToFile(Bitmap bitmap, File file) {
        try {
            ByteArrayOutputStream bos = new ByteArrayOutputStream();
            bitmap.compress(Bitmap.CompressFormat.JPEG, 100, bos);
            byte[] bitmapdata = bos.toByteArray();

            FileOutputStream fos = new FileOutputStream(file);
            fos.write(bitmapdata);
            fos.flush();
            fos.close();

            return file;
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
    }


    public static Bitmap getPicThumbnail(final Context context, final File file) {
        try {
            int size = (int) CommonUtils.convertDpToPixel(60, context);
            BitmapFactory.Options options = new BitmapFactory.Options();
            options.inJustDecodeBounds = true;

            if (file.exists()) {
                BitmapFactory.decodeFile(file.getPath(), options);
                options.inSampleSize = calculateInSampleSize(options, size, size);
                options.inJustDecodeBounds = false;
                return BitmapFactory.decodeFile(file.getPath(), options);
            }
        } catch (Exception e) {

        }
        return null;
    }


    static public Bitmap getCropBitmap(Bitmap bitmap) {
        int destSize = bitmap.getWidth();
        if (bitmap.getWidth() > bitmap.getHeight())
            destSize = bitmap.getHeight();

        int startX = (bitmap.getWidth() - destSize) / 2;
        int startY = (bitmap.getHeight() - destSize) / 2;
        Bitmap cropBitmap = Bitmap.createBitmap(bitmap, startX, startY, destSize, destSize);

        return cropBitmap;
    }

縮圖：
https://disp.cc/b/KnucklesNote/9C95

搜尋：
public static Bitmap decodeSampledBitmapFromFile(String file, int reqWidth, int reqHeight)

Bitmap dd = CommonUtils.createPhotoSticker(outputFile.getPath(),50,50);



==================================================================================

public static void getChatRoomThumbnail(File file){
        BitmapFactory.Options options = new BitmapFactory.Options();
        options.inJustDecodeBounds = true;
        BitmapFactory.decodeFile(file.getAbsolutePath(),options);

}

BitmapFactory.decodeFile()第一個參數放絕對路徑
file.getAbsolutePath()取得檔案絕對路徑
getAbsolutePath()返回的路徑字符串可能是特定操作系統的格式
getPath() 方法的返回值取決於你在創建 File 對象時使用的路徑是相對還是絕對路徑

==================================================================================
清除快取：

public static void checkExternalSharing(Context context){
    Resources resources = context.getResources();
    String app_name = resources.getString(R.string.app_name);
    String tableOfContents = Environment.DIRECTORY_PICTURES + File.separator + app_name + File.separator + "externalSharing";
    File download = Environment.getExternalStoragePublicDirectory(tableOfContents);
    StringUtils.HaoLog("checkExternalSharing " + download);
    if(download.exists()) {
        File[] files = download.listFiles();
        for (File file : files) {
            if (file.isFile()) {
                String fileName = file.getName();
                StringUtils.HaoLog("checkExternalSharing " + fileName);
                deleteExternalSharing(file);
            }
        }
    }
}

    private static void deleteExternalSharing(File file){
        if(file.isFile()){
            file.delete();
        }
    }
    
==================================================================================
電話擴音問題：
AudioManager.MODE_NORMAL、
AudioManager.MODE_RINGTONE、
AudioManager.MODE_CALL_SCREENING

AudioManager.MODE_IN_CALL、
AudioManager.MODE_IN_COMMUNICATION、


void saveCurrentVolume(){
    AudioManager audioManager = (AudioManager) getSystemService(Context.AUDIO_SERVICE);
    int CurrentVolume = audioManager.getStreamVolume(AudioManager.STREAM_MUSIC);
    int mode = audioManager.getMode();
    boolean phoneOn = audioManager.isSpeakerphoneOn();

    StringUtils.HaoLog("saveCurrentVolume= "+CurrentVolume);//setCommunicationDevice  clearCommunicationDevice
    StringUtils.HaoLog("saveCurrentVolume mode= "+mode);
    StringUtils.HaoLog("saveCurrentVolume phoneOn= "+phoneOn);
}

if (PackageManager.PERMISSION_GRANTED != ActivityCompat.checkSelfPermission(WebJitisiMeetActivity.this, Manifest.permission.MODIFY_AUDIO_SETTINGS)) {
    permissions.add(Manifest.permission.MODIFY_AUDIO_SETTINGS);
}


<uses-permission android:name="android.permission.RECORD_AUDIO" /> <!-- 錄製音訊 -->
<uses-permission android:name="android.permission.MODIFY_AUDIO_SETTINGS" /> <!-- 控制揚聲器 -->

==================================================================================

/**
* 額外自訂義推送資訊
*/
private String HashMapToJson(String userId, String domain){
    String[] keyValuePairs = new String[] { "userId", userId, "domain", domain };
    Gson json = new Gson();
    return json.toJson(keyValuePairs);
}


==================================================================================

private boolean checkPublishPermission() {
    List<String> permissions = new ArrayList<>();

    if (PackageManager.PERMISSION_GRANTED != ActivityCompat.checkSelfPermission(WebJitisiMeetActivity.this, Manifest.permission.CAMERA)) {
        permissions.add(Manifest.permission.CAMERA);
    }
    if (PackageManager.PERMISSION_GRANTED != ActivityCompat.checkSelfPermission(WebJitisiMeetActivity.this, Manifest.permission.RECORD_AUDIO)) {
        permissions.add(Manifest.permission.RECORD_AUDIO);
    }

    if (permissions.size() != 0) {
        //ActivityCompat.requestPermissions(WebJitisiMeetActivity.this, (String[]) permissions.toArray(new String[0]), 667);
        WebJitisiMeetActivity.this.requestPermissions((String[]) permissions.toArray(new String[0]),667);
        return false;
    }
    return true;
}

==================================================================================

public HttpAfReturn getJhttpAfReturn(Request.Builder request) {
    OkHttpClient client = getUnsafeOkHttpClient().newBuilder().build();
    try {
        Response response = client.newCall(request.build()).execute();
        String body = response.body().string();
        StringUtils.HaoLog("body=" + body);
        HttpAfReturn httpReturn = new Gson().fromJson(body, HttpAfReturn.class);
        StringUtils.HaoLog("getJhttpAfReturn");
        StringUtils.HaoLog(response.header("url") + " " + httpReturn.success + " " + httpReturn.data);
        StringUtils.HaoLog("getJhttpAfReturn end");
        return httpReturn;
    } catch (IOException | JsonSyntaxException e) {
        e.printStackTrace();
    }
    return new HttpAfReturn();
}


HttpReturn gethttpReturn(Request.Builder request) {
    OkHttpClient client = getUnsafeOkHttpClient().newBuilder().build();
    try {
        Response response = client.newCall(request.build()).execute();
        if (response.code() == 200) {
            String body = response.body().string();
            StringUtils.HaoLog("body=" + body);
            HttpReturn httpReturn = new Gson().fromJson(body, HttpReturn.class);
            if (httpReturn != null) {
                StringUtils.HaoLog(response.request().url().toString(), httpReturn);
                return httpReturn;
            } else
                StringUtils.HaoLog(response.request().url() + " " + response.code() + " body=" + body);
        }
    } catch (IOException | IllegalStateException e) {
        StringUtils.HaoLog("gethttpReturn error=" + request + " " + e.toString());
        e.printStackTrace();
    }
    return new HttpReturn();
}
==================================================================================
Android清除WebView缓存

    public void clearCach(){
        try {
            if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP){
                CookieManager.getInstance().removeAllCookies(null);
            } else {
                CookieSyncManager.createInstance(getApplicationContext());
                CookieManager.getInstance().removeAllCookie();
                CookieSyncManager.getInstance().sync();
            }
            new WebView(getApplicationContext()).clearCache(true);
            File cacheFile = new File(getCacheDir().getParent() + "/app_webview");
            clearCacheFolder(cacheFile,System.currentTimeMillis());
            StringUtils.HaoLog("clearCach= "+System.currentTimeMillis());
        }catch (Exception e){
            e.printStackTrace();
        }
    }

    public static int clearCacheFolder(File dir, long time){
        int deletedFiles = 0;
        if(dir != null && dir.isDirectory()){
            try {
                for(File child : dir.listFiles()){
                    if(child.isDirectory()){
                        deletedFiles +=  clearCacheFolder(child, time);
                    }
                    if(child.lastModified() < time){
                        if(child.delete()){
                            deletedFiles++;
                        }
                    }
                }
            }catch (Exception e){
                e.printStackTrace();
            }
        }
        return deletedFiles;
    }

==================================================================================

儲存String到 緩存路徑 getCacheDir().getAbsolutePath()：

    public static void saveWebViewVersion(String data, Context context) {
        String fileName = "webViewVersion.txt";
        String filePath = context.getCacheDir().getAbsolutePath() + File.separator + fileName;
        try {
            File file = new File(filePath);
            FileOutputStream fos = new FileOutputStream(file);
            fos.write(data.getBytes());
            fos.close();
            StringUtils.HaoLog("文件保存成功");
        } catch (IOException e) {
            e.printStackTrace();
            StringUtils.HaoLog("保存文件失敗"+e);
        }
    }

讀取txt檔案回傳String
    public static String readTextFromFile(Context context) {
        String fileName = "webViewVersion.txt";
        String filePath = context.getCacheDir().getAbsolutePath() + File.separator + fileName;
        StringBuilder stringBuilder = new StringBuilder();
        try {
            File file = new File(filePath);
            FileInputStream fis = new FileInputStream(file);
            InputStreamReader isr = new InputStreamReader(fis);
            BufferedReader bufferedReader = new BufferedReader(isr);
            String line;
            while ((line = bufferedReader.readLine()) != null) {
                stringBuilder.append(line);
            }
            bufferedReader.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return stringBuilder.toString();
    }


==================================================================================

    public void getWebVersion() {
        new Thread(() -> {
            try {
                URL url = new URL(getMainWebURL(false));
                Document doc = Jsoup.parse(url, 3000);
                Element bodyElement = doc.body();
                String bodyContent = bodyElement.text();
                //取得版號，存到cash目錄下txt檔
                String fileName = "webViewVersion.txt";
                //String filePath = getCacheDir().getAbsolutePath() + File.separator + fileName;
                String tableOfContents = Environment.DIRECTORY_PICTURES + File.separator + "Lale 企業" + File.separator + fileName;
                File file = new File(tableOfContents);
                if(file.exists()){
                    //如果存在判斷檔案內版本是否不同，如果為true，則存檔以及清除cash
                    String oldVersion = FileUtils.readTextFromFile(file);
                    if(!oldVersion.equals(bodyContent)){
                        FileUtils.saveWebViewVersion(MainWebActivity.this, bodyContent);
                        cleanWebviewCache();
                    }
                } else {
                    //如果不存在表示為第一次使用app，則存檔以及清除cash
                    FileUtils.saveWebViewVersion(MainWebActivity.this, bodyContent);
                    cleanWebviewCache();
                }
            }catch (IOException e){
                e.printStackTrace();
            }
        }).start();
    }

==================================================================================

URL 轉  Bitmap：

public static Bitmap getBitmapFromURL(String imageUrl) {
    try {
        URL url = new URL(imageUrl);
        HttpURLConnection connection = (HttpURLConnection) url.openConnection();
        connection.setDoInput(true);
        connection.connect();
        InputStream input = connection.getInputStream();
        Bitmap bitmap = BitmapFactory.decodeStream(input);
        return bitmap;
    } catch (Exception e) {
        e.printStackTrace();
        return null;
    }
}
==================================================================================

影片縮圖，回傳 Bitmap物件，回傳就能呼叫resizeAndConvertToBase64()方法做縮圖

public static Bitmap getVideoThumbnail(String videoPath) {
    Bitmap thumbnail = null;
    try {
        MediaMetadataRetriever retriever = new MediaMetadataRetriever();
        retriever.setDataSource(videoPath);
        int width = Integer.parseInt(retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_VIDEO_WIDTH));
        int height = Integer.parseInt(retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_VIDEO_HEIGHT));
        // 獲取第一幀圖像
        thumbnail = retriever.getFrameAtTime(0, MediaMetadataRetriever.OPTION_CLOSEST);
        if (thumbnail != null) {
            // 按照指定的寬高進行縮放
            thumbnail = Bitmap.createScaledBitmap(thumbnail, width, height, false);
        }
        retriever.release();
    } catch (Exception e) {}
    return thumbnail;
}

==================================================================================

MediaMetadataRetriever retriever = new MediaMetadataRetriever();
retriever.setDataSource(file.getPath());
String width = retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_VIDEO_WIDTH);
String height = retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_VIDEO_HEIGHT);

if(".jpg".equals(fileType(file.getName()))){
  String pic = ThumbnailUtils.resizeAndConvertToBase64(file.getPath(),50);
  jsonObject.put("thumbnail",pic);
} else {
  Bitmap originalBitmap = ThumbnailUtils.getVideoThumbnail(file.getPath());
  String pic = ThumbnailUtils.resizeAndConvertToBase64(originalBitmap,50);
  jsonObject.put("thumbnail",pic);
}

==================================================================================

Build.VERSION.SDK_INT  →  是一個表示設備當前 Android 版本的整數值。 29
Build.VERSION_CODES.LOLLIPOP  →  是一個表示 Android  21版本的整數常量。 


==================================================================================
firebase 推播 棄用之替代寫法，FirebaseMessaging

FirebaseMessaging.getInstance().getToken().addOnSuccessListener(new OnSuccessListener<String>() {
    @Override
    public void onSuccess(String s) {         
    }
});


FirebaseMessaging.getInstance().getToken().addOnSuccessListener(deviceToken -> {
            if (!TextUtils.isEmpty(deviceToken)) {
                SharedPreferences pref = PreferenceManager.getDefaultSharedPreferences(AllData.context);
                new Thread(() -> {
                    HttpReturn pu;
                    try {
                        JSONObject UserIds = new JSONObject(pref.getString("UserIds", "{}"));
                        StringUtils.HaoLog("UserIds= " + UserIds);
                        StringUtils.HaoLog("deviceToken= " + deviceToken);

                        if (UserIds.length() <= 1){
                            String userId = UserControlCenter.getUserMinInfo().userId;
                            String uuid = Settings.Secure.getString(activity.getContentResolver(), Settings.Secure.ANDROID_ID);
                            String customerProperties = HashMapToJson(userId,AllData.getMainServer(),false, "");
                            pu = CloudUtils.iCloudUtils.setPusher(userId, deviceToken, uuid, customerProperties);
                        } else {
                            String userId = UserControlCenter.getUserMinInfo().userId;
                            String uuid = Settings.Secure.getString(activity.getContentResolver(), Settings.Secure.ANDROID_ID);
                            UserControlCenter.switchAccounts(userId);
                            pu = CloudUtils.iCloudUtils.updatePusher(userId, uuid);
                        }
                        StringUtils.HaoLog("setPusher=" + pu);

                    } catch (JSONException e) {
                        e.printStackTrace();
                    }
                    activity.runOnUiThread(() -> {
                        activity.finish();
                    });
                }).start();
            }
        });

==================================================================================

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="44dp"
                android:layout_marginLeft="42dp"
                android:layout_marginRight="42dp"
                android:layout_marginBottom="15dp"
                android:focusable="true"
                android:focusableInTouchMode="true"
                android:orientation="horizontal">

屬性介紹：
android:focusable="true"

用於指定視圖是否可以獲得焦點。
當您將 android:focusable 屬性設置為 true 時，表示該視圖可以獲得焦點。焦點是指當使用者與應用程序交互時，
應用程序中的視圖元素可以接收和處理使用者輸入的能力。

以下是一些常見的用法和注意事項：
使用者交互：當一個視圖可以獲得焦點時，使用者可以通過點擊、觸摸或其他交互方式將焦點設置到該視圖上。
例如，EditText 預設是可以獲得焦點的，用戶可以點擊 EditText 並開始輸入文本。
鍵盤焦點：當視圖獲得焦點時，系統會將鍵盤焦點設置到該視圖上，這意味著用戶可以通過鍵盤進行相應的操作，
例如輸入文本或使用方向鍵進行導航。
聚焦順序：如果多個視圖都可以獲得焦點，則根據聚焦順序，系統將在這些視圖之間進行焦點切換。
您可以使用 android:nextFocusUp、android:nextFocusDown、android:nextFocusLeft、android:nextFocusRight 
等屬性來指定焦點切換的順序。

請注意以下幾點：
預設情況下，大多數視圖（如 Button、EditText 等）都可以獲得焦點，但某些視圖（如 TextView）可能不具備焦點能力，
除非您明確將 android:focusable 設置為 true。
如果一個視圖的父級視圖（例如 LinearLayout）具有 android:focusable="true" 的屬性，則該視圖也將繼承父級視圖的焦點能力，
即使該視圖本身沒有明確設置 android:focusable 屬性。
您可以使用 android:focusableInTouchMode 屬性來指定視圖是否可以在觸摸模式下獲得焦點。
總之，android:focusable="true" 屬性用於指定視

==================================================================================












