用廣播做監聽器
    
==================================================================================   
        DownloadManager downloadManager = (DownloadManager) getSystemService(DOWNLOAD_SERVICE);
        downloadManager.enqueue(request);
        long Id = downloadManager.enqueue(request);
        listener(Id,data);


          private BroadcastReceiver broadcastReceiver;
    private void listener(final long Id,JSONObject data) {
        // 註冊廣播監聽系統的下載完成事件。
        IntentFilter intentFilter = new IntentFilter(DownloadManager.ACTION_DOWNLOAD_COMPLETE);
        broadcastReceiver = new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                long ID = intent.getLongExtra(DownloadManager.EXTRA_DOWNLOAD_ID, -1);
                if (ID == Id) {
                    StringUtils.HaoLog("dd= "+"完成");
                    shareFileType(data);
                }
            }
        };
        registerReceiver(broadcastReceiver, intentFilter);
    }  

==================================================================================

 File myFilePath = new File(Environment.getExternalStorageDirectory() + "/DB_BACK");
            if (!myFilePath.exists()) {
                myFilePath.mkdir();
            }

            File fileRestore = new File(Environment.getExternalStorageDirectory() + "/DB_BACK/DB_BACK_POS" + ".db");
            if (fileRestore.exists()) {
                InputStream in = new FileInputStream(fileRestore);
                SQLiteDatabase db = getReadableDatabase();
//                SQLite sqLite = new SQLite(context);
//                SQLiteDatabase db = sqLite.getReadableDatabase();
                FileOutputStream fw = new FileOutputStream(new File(db.getPath()));
                db.close();
//                sqLite.close();

                byte data[] = new byte[in.available()];
                in.read(data, 0, in.available());
                fw.write(data);

                fw.close();
                in.close();

                fileRestore.delete();
                }
==================================================================================
存到內存

   String fileName = "ONLINE.csv";
            File fileRestore = new File(Environment.getExternalStorageDirectory() + File.separator + "DB_BACK" + File.separator + fileName)
==================================================================================

private void UploadCompression(){
        String fileName = "DB_BACK_ORDER.db";
        File backupFile = new File(Environment.getExternalStorageDirectory() + File.separator + "DB_BACK" + File.separator + fileName);
        File zipFile = new File(Environment.getExternalStorageDirectory()+File.separator+"DB_BACK"+File.separator +"DB_BACK_ORDER.zip");
        try{
            InputStream input = new FileInputStream(backupFile);
            ZipOutputStream zipOut = null;
            zipOut = new ZipOutputStream(new FileOutputStream(zipFile));
            zipOut.putNextEntry(new ZipEntry(backupFile.getName()));
            int temp = 0;
            while((temp = input.read())!=-1){
                zipOut.write(temp);
            }
            input.close();
            zipOut.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }

==================================================================================

        File folder = new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES), fileName);
        if (!folder.exists()) {
            folder.mkdirs(); // 創建子目錄
        }
        File file = new File(folder, fileName);
        request.setDestinationUri(Uri.fromFile(file));
==================================================================================
event id = onlyKey
[
  {
    "onlyKey": "event_1636913865210068992",
    "name": "20210811_194151.jpg",
    "url": "https://laledev0.flowring.com/fileserver/file/download/9a35af5787ad4766a48df375aa8a0321"
  }
]
event_163691
==================================================================================

讀取目錄底下的檔案名稱
File download = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS);
                if(download.exists()) {
                    File[] files = download.listFiles();
                    for (File file : files) {
                        if (file.isFile()) {
                            String fileName = file.getName();
                            StringUtils.HaoLog("dd= fileName " + fileName);
                        }
                    }
                }
==================================================================================
    public static final String ACTION_DOWNLOAD_COMPLETE = "android.intent.action.DOWNLOAD_COMPLETE";
    public static final String ACTION_NOTIFICATION_CLICKED = "android.intent.action.DOWNLOAD_NOTIFICATION_CLICKED";
    public static final String ACTION_VIEW_DOWNLOADS = "android.intent.action.VIEW_DOWNLOADS";
    public static final String COLUMN_BYTES_DOWNLOADED_SO_FAR = "bytes_so_far";
    public static final String COLUMN_DESCRIPTION = "description";
    public static final String COLUMN_ID = "_id";
    public static final String COLUMN_LAST_MODIFIED_TIMESTAMP = "last_modified_timestamp";


這些是 Android 下載管理器 (Download Manager) 類別中所使用的常數，具體說明如下：

ACTION_DOWNLOAD_COMPLETE：下載完成廣播 (broadcast) 的動作名稱。
ACTION_NOTIFICATION_CLICKED：點擊下載通知欄位 (notification) 的廣播動作名稱。
ACTION_VIEW_DOWNLOADS：顯示下載清單的活動 (activity) 的動作名稱。
COLUMN_BYTES_DOWNLOADED_SO_FAR：用於表示已經下載的資料大小的欄位名稱。
COLUMN_DESCRIPTION：用於表示下載描述 (description) 的欄位名稱。
COLUMN_ID：用於表示下載 ID 的欄位名稱。
COLUMN_LAST_MODIFIED_TIMESTAMP：用於表示下載檔案最後修改時間的欄位名稱。
這些常數可以在程式中用來註冊下載完成廣播接收器、建立下載通知欄位、顯示下載清單等等操作。
例如，當下載完成後，可以透過註冊 ACTION_DOWNLOAD_COMPLETE 廣播接收器來接收下載完成通知，
並在接收到通知後進行相應的處理；或者在進行下載時，可以使用 COLUMN_DESCRIPTION 欄位來設定下載描述，
然後在建立下載通知欄位時顯示相應的描述資訊。

==================================================================================

Thread.currentThread().getName() 看到現在的 Thread 名稱
==================================================================================

public class ReadExcelFile {
    public static void main(String[] args) throws IOException {
        File file = new File("example.xlsx");
        FileInputStream inputStream = new FileInputStream(file);
        Workbook workbook = WorkbookFactory.create(inputStream);
        Sheet sheet = workbook.getSheetAt(0);
        for (Row row : sheet) {
            for (Cell cell : row) {
                System.out.print(cell.toString() + "\t");
            }
            System.out.println();
        }
        workbook.close();
        inputStream.close();
    }
}

==================================================================================
URLConnection 可以得到檔案類型
connection.getContentType()

//URLConnection connection;
//try{
//    connection = new URL(uri).openConnection();
//}catch (IOException e){
//  StringUtils.HaoLog("cacheShareFileType connectionError=" + e);
//  return;
//}
//final SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH mm ss SSS");
//String fileName = oldFileName == null ? sdf.format(new Date().getDate()) + FileUtils.toExtension(connection.getContentType()) : oldFileName;


==================================================================================
    private BroadcastReceiver broadcastReceiver;
    private void listener(final long Id, String fileName, String tableOfContents) {
        // 註冊廣播監聽系統的下載完成事件。
        IntentFilter intentFilter = new IntentFilter(DownloadManager.ACTION_DOWNLOAD_COMPLETE);
        broadcastReceiver = new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                long ID = intent.getLongExtra(DownloadManager.EXTRA_DOWNLOAD_ID, -1);
                if (ID == Id) {
                    StringUtils.HaoLog("分享檔案下載動作完成");
                    shareFileType(fileName,tableOfContents);
                }
            }
        };
        registerReceiver(broadcastReceiver, intentFilter);
    }
==================================================================================


// 創建一個File對象，代表Excel檔案
File file = new File("path/to/excel/file.xlsx");

// 創建一個FileInputStream對象，用於讀取Excel檔案
FileInputStream inputStream = new FileInputStream(file);

// 創建一個XSSFWorkbook對象，代表整個Excel檔案
XSSFWorkbook workbook = new XSSFWorkbook(inputStream);

// 獲取第一個工作表
XSSFSheet sheet = workbook.getSheetAt(0);

// 獲取第一行
XSSFRow row = sheet.getRow(0);

// 獲取第一列
XSSFCell cell = row.getCell(0);

// 讀取單元格中的值
String value = cell.getStringCellValue();

// 關閉工作簿和流
workbook.close();
inputStream.close();

==================================================================================
 // 開啟Excel文件
        FileInputStream inputStream = new FileInputStream(new File("example.xlsx"));

        // 建立工作簿對象
        Workbook workbook = new XSSFWorkbook(inputStream);

        // 選擇要操作的工作表
        Sheet sheet = workbook.getSheetAt(0);

        // 遍歷所有行
        for (Row row : sheet) {

            // 遍歷所有列
            for (Cell cell : row) {

                // 判斷單元格類型
                switch (cell.getCellType()) {
                    case STRING:
                        System.out.print(cell.getStringCellValue() + "\t");
                        break;
                    case NUMERIC:
                        System.out.print(cell.getNumericCellValue() + "\t");
                        break;
                    case BOOLEAN:
                        System.out.print(cell.getBooleanCellValue() + "\t");
                        break;
                    default:
                        System.out.print("\t");
                }
            }
            System.out.println();
        }

        // 關閉工作簿和輸入流
        workbook.close();
        inputStream.close();
 ==================================================================================
Handler 切換執行續
         if(folder.exists()){
            StringUtils.HaoLog("檔案存在");
            new Handler(Looper.getMainLooper()).post(() -> {
                MainWebActivity.categoryFileType(folder);
            });
            //執行開檔
        }
 ==================================================================================

  public ArrayList<ExcelBean> getExcelData(String xlsName, int index) {
    ArrayList<ExcelBean> list = new ArrayList<>();
    //获取文件管理器
    AssetManager manager = context.getAssets();
    try {
      Workbook workbook = Workbook.getWorkbook(manager.open(xlsName));
      Sheet sheet = workbook.getSheet(index);
      //表格一共有多少行
      int sheetRows = sheet.getRows();
      //将数据添加到集合中
      for (int i = 0; i < sheetRows; i++) {
        ExcelBean bean = new ExcelBean();
        //获取列的数据
        bean.setChinese(sheet.getCell(0, i).getContents());
        bean.setEnglish(sheet.getCell(1, i).getContents());
        bean.setSpell(sheet.getCell(2, i).getContents());
        list.add(bean);
      }
      workbook.close();
    } catch (Exception e) {
      e.printStackTrace();
    }
    return list;
  }

==================================================================================

檢查版本

public boolean checkAppNeedUpdate() {
        Request.Builder request = new Request.Builder()
                .url(AllData.getMainServer() + "/util/app/version/android")
                .get()
                .addHeader("Content-Type", "application/json");
        HttpReturn httpReturn = gethttpReturn(request);
        String data = new Gson().toJson(httpReturn.data);
        GetMinVersion dbVersion = new Gson().fromJson(data,GetMinVersion.class);
        String appVersion = MainWebActivity.getVersionName(AllData.context);

        if(dbVersion != null && dbVersion.version != null && !dbVersion.version.isEmpty()
        && appVersion != null && !appVersion.isEmpty()){
            Boolean newVersion = appVersion.equals(dbVersion.version);
            if(newVersion){
                return false;
            } else {
                return true;
            }
        }else {
            StringUtils.HaoLog("googleVersion 為 null");
            return false;
        }
    }



    public void checkAppNeedUpdate() {
        new Thread(() -> {
            if (CloudUtils.iCloudUtils.checkAppNeedUpdate())
                runOnUiThread(() -> {
                    showUpgradeDialog();
                });
        }).start();
    }

new AlertDialog.Builder((Context) this)


public class GetMinVersion {
    public String osName = null;
    public String version = null;
}

获取软件版本号，对应AndroidManifest.xml下android:versionName
獲取軟件版本號，對應AndroidManifest.xml下android:versionName
==================================================================================
H5喚起android app，啟動關聯應用，在MAIN下面設定

    <intent-filter android:autoVerify="true">
        <action android:name="android.intent.action.VIEW" />
        <category android:name="android.intent.category.DEFAULT" />
        <category android:name="android.intent.category.BROWSABLE" />
        <data android:scheme="laletoc"/>
    </intent-filter>
https://blog.csdn.net/YukimineRyuu/article/details/106063792
https://juejin.cn/post/7097784616961966094

<intent-filter>
    <action android:name="android.intent.action.SEND" />
    <category android:name="android.intent.category.DEFAULT" />
    <data android:mimeType="*/*" />
</intent-filter>

==================================================================================

Intent intent = new Intent(AllData.context, MainWebActivity.class);
intent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);// 將啟動模式設置為 FLAG_ACTIVITY_SINGLE_TOP
intent.setType(getIntent().getType()); // 設置 Intent 的類型為從接收到的 Intent 中獲取的類型。

Uri uri = getIntent().getParcelableExtra(Intent.EXTRA_STREAM);
String extraText = getIntent().getStringExtra(Intent.EXTRA_TEXT);
if (uri != null){ //從接收到的 Intent 中獲取圖片的 Uri 和文字描述，如果有圖片，就將接收到的 Intent 的所有額外訊息攜帶到新的 Intent 中。
    intent.putExtras(getIntent());
}
intent.putExtra(Intent.EXTRA_TEXT, extraText);//將文字描述放入 Intent 的額外訊息中。
intent.setAction(getIntent().getAction()); // android.intent.action.SEND
// 將原始 Intent 的操作設置為新的 Intent 的操作。
{
    Intent intent1 = new Intent(getIntent().getAction());
    intent1.setAction(getIntent().getAction());
    if (uri != null){
        intent1.putExtras(getIntent());
    }
    intent1.putExtra(Intent.EXTRA_TEXT, extraText);
    LocalBroadcastManager.getInstance(this).sendBroadcast(intent1); //發送廣播訊息
}
startActivity(intent);
finish();

==================================================================================
加上監聽器類型，廣播接收器才會接收到設置setType，預設是沒有接收類型
try {
    itFilter.addDataType("*/*");
}catch (IntentFilter.MalformedMimeTypeException e){
    StringUtils.HaoLog( e.toString());
    e.printStackTrace();
}

==================================================================================
接受分享多選的動作，接受到之後用陣列裝資料

ArrayList<Uri> uris = getIntent().getParcelableArrayListExtra(Intent.EXTRA_STREAM);
        if (uris != null){
            //intent1.putExtras(getIntent());
            for(Uri uri : uris){
                StringUtils.HaoLog("BroadcastReceiver=" +" 2 "+ uri);
            }
         }

==================================================================================
接受分享多選的動作：這種處理方法不適合微信，因為微信多選分享檔案是壓縮成ZIP，所以ClipData會是null，在來
會取不到URI和type，所以未來如果line可以多選分享說不定能用上

        ClipData clipData = getIntent().getClipData();
        if (clipData != null) {
            // 處理多個共享的內容
            for (int i = 0; i < clipData.getItemCount(); i++) {
                Uri ClipDataUri = clipData.getItemAt(i).getUri();
                StringUtils.HaoLog("dd= "+ClipDataUri);
                // 處理共享的內容，例如保存到本地文件或在應用中顯示

                ClipData.Item item = clipData.getItemAt(i);
                String type = getContentResolver().getType(item.getUri());
                //取得檔案type
            }
        } else {
            Intent intent1 = new Intent(getIntent().getAction());
            intent1.setAction(getIntent().getAction());
            intent1.setType(getIntent().getType());
            if (uri != null){
                intent1.putExtras(getIntent());
            }
            intent1.putExtra(Intent.EXTRA_TEXT, extraText);
            LocalBroadcastManager.getInstance(this).sendBroadcast(intent1); //發送廣播訊息
        }
==================================================================================

private void gotoShare(){
    try {
        JSONArray jsonArray = new JSONArray();
        JSONObject jsonObject = new JSONObject();
        jsonObject.put("mimeType", "message");
        jsonObject.put("string", "www.google.com");
        jsonArray.put(jsonObject);
        sendToWeb(new JSONObject().put("type","gotoShare").put("data",jsonArray).toString());
    } catch (JSONException e) {
        e.printStackTrace();
    }
}

==================================================================================

//創建照片路徑，getCacheDir()取得內部Cache路徑
private File createImageFile() throws IOException {
    String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date());
    String imageFileName = "JPEG_" + timeStamp + ".jpg";
    File image = new File(getCacheDir(), imageFileName);
    currentPhotoPath = image.getAbsolutePath();
    return image;
}

==================================================================================
改寫方法：
    public String getBase64FromPath(Uri uri) {
        String base64 = "";
        try {
            InputStream inputStream = getContentResolver().openInputStream(uri);
            byte[] buffer = new byte[inputStream.available() + 100];
            int length = inputStream.read(buffer);
            base64 = Base64.encodeToString(buffer, 0, length, Base64.DEFAULT);
            inputStream.close();
        } catch (IOException e) {
            StringUtils.HaoLog("錯誤訊息"+e);
            e.printStackTrace();
        }
        return base64;
    }

==================================================================================
    String thumbnail = getBase64FromPath(imageUri);
    try {
        JSONArray jsonArray = new JSONArray();
        JSONObject jsonObject = new JSONObject();
        jsonObject.put("onlyKey","hashcode");
        jsonObject.put("mimeType",type);
        jsonObject.put("name",fileName);
        jsonObject.put("thumbnail",thumbnail);
        jsonArray.put(jsonObject);
        sendToWeb(new JSONObject().put("type","gotoShare").put("data",jsonArray).toString());
    } catch (JSONException e) {
        e.printStackTrace();
    }
==================================================================================
縮圖：

    public static File bitmapToFile(Bitmap bitmap, File file) {
        try {
            ByteArrayOutputStream bos = new ByteArrayOutputStream();
            bitmap.compress(Bitmap.CompressFormat.JPEG, 100, bos);
            byte[] bitmapdata = bos.toByteArray();

            FileOutputStream fos = new FileOutputStream(file);
            fos.write(bitmapdata);
            fos.flush();
            fos.close();

            return file;
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
    }


    public static Bitmap getPicThumbnail(final Context context, final File file) {
        try {
            int size = (int) CommonUtils.convertDpToPixel(60, context);
            BitmapFactory.Options options = new BitmapFactory.Options();
            options.inJustDecodeBounds = true;

            if (file.exists()) {
                BitmapFactory.decodeFile(file.getPath(), options);
                options.inSampleSize = calculateInSampleSize(options, size, size);
                options.inJustDecodeBounds = false;
                return BitmapFactory.decodeFile(file.getPath(), options);
            }
        } catch (Exception e) {

        }
        return null;
    }


    static public Bitmap getCropBitmap(Bitmap bitmap) {
        int destSize = bitmap.getWidth();
        if (bitmap.getWidth() > bitmap.getHeight())
            destSize = bitmap.getHeight();

        int startX = (bitmap.getWidth() - destSize) / 2;
        int startY = (bitmap.getHeight() - destSize) / 2;
        Bitmap cropBitmap = Bitmap.createBitmap(bitmap, startX, startY, destSize, destSize);

        return cropBitmap;
    }

縮圖：
https://disp.cc/b/KnucklesNote/9C95

搜尋：
public static Bitmap decodeSampledBitmapFromFile(String file, int reqWidth, int reqHeight)

Bitmap dd = CommonUtils.createPhotoSticker(outputFile.getPath(),50,50);



==================================================================================

public static void getChatRoomThumbnail(File file){
        BitmapFactory.Options options = new BitmapFactory.Options();
        options.inJustDecodeBounds = true;
        BitmapFactory.decodeFile(file.getAbsolutePath(),options);

}

BitmapFactory.decodeFile()第一個參數放絕對路徑
file.getAbsolutePath()取得檔案絕對路徑
getAbsolutePath()返回的路徑字符串可能是特定操作系統的格式
getPath() 方法的返回值取決於你在創建 File 對象時使用的路徑是相對還是絕對路徑

==================================================================================
清除快取：

public static void checkExternalSharing(Context context){
    Resources resources = context.getResources();
    String app_name = resources.getString(R.string.app_name);
    String tableOfContents = Environment.DIRECTORY_PICTURES + File.separator + app_name + File.separator + "externalSharing";
    File download = Environment.getExternalStoragePublicDirectory(tableOfContents);
    StringUtils.HaoLog("checkExternalSharing " + download);
    if(download.exists()) {
        File[] files = download.listFiles();
        for (File file : files) {
            if (file.isFile()) {
                String fileName = file.getName();
                StringUtils.HaoLog("checkExternalSharing " + fileName);
                deleteExternalSharing(file);
            }
        }
    }
}

    private static void deleteExternalSharing(File file){
        if(file.isFile()){
            file.delete();
        }
    }
    
==================================================================================
電話擴音問題：
AudioManager.MODE_NORMAL、
AudioManager.MODE_RINGTONE、
AudioManager.MODE_CALL_SCREENING

AudioManager.MODE_IN_CALL、
AudioManager.MODE_IN_COMMUNICATION、


void saveCurrentVolume(){
    AudioManager audioManager = (AudioManager) getSystemService(Context.AUDIO_SERVICE);
    int CurrentVolume = audioManager.getStreamVolume(AudioManager.STREAM_MUSIC);
    int mode = audioManager.getMode();
    boolean phoneOn = audioManager.isSpeakerphoneOn();

    StringUtils.HaoLog("saveCurrentVolume= "+CurrentVolume);//setCommunicationDevice  clearCommunicationDevice
    StringUtils.HaoLog("saveCurrentVolume mode= "+mode);
    StringUtils.HaoLog("saveCurrentVolume phoneOn= "+phoneOn);
}

if (PackageManager.PERMISSION_GRANTED != ActivityCompat.checkSelfPermission(WebJitisiMeetActivity.this, Manifest.permission.MODIFY_AUDIO_SETTINGS)) {
    permissions.add(Manifest.permission.MODIFY_AUDIO_SETTINGS);
}


<uses-permission android:name="android.permission.RECORD_AUDIO" /> <!-- 錄製音訊 -->
<uses-permission android:name="android.permission.MODIFY_AUDIO_SETTINGS" /> <!-- 控制揚聲器 -->

==================================================================================

/**
* 額外自訂義推送資訊
*/
private String HashMapToJson(String userId, String domain){
    String[] keyValuePairs = new String[] { "userId", userId, "domain", domain };
    Gson json = new Gson();
    return json.toJson(keyValuePairs);
}


==================================================================================

private boolean checkPublishPermission() {
    List<String> permissions = new ArrayList<>();

    if (PackageManager.PERMISSION_GRANTED != ActivityCompat.checkSelfPermission(WebJitisiMeetActivity.this, Manifest.permission.CAMERA)) {
        permissions.add(Manifest.permission.CAMERA);
    }
    if (PackageManager.PERMISSION_GRANTED != ActivityCompat.checkSelfPermission(WebJitisiMeetActivity.this, Manifest.permission.RECORD_AUDIO)) {
        permissions.add(Manifest.permission.RECORD_AUDIO);
    }

    if (permissions.size() != 0) {
        //ActivityCompat.requestPermissions(WebJitisiMeetActivity.this, (String[]) permissions.toArray(new String[0]), 667);
        WebJitisiMeetActivity.this.requestPermissions((String[]) permissions.toArray(new String[0]),667);
        return false;
    }
    return true;
}

==================================================================================

public HttpAfReturn getJhttpAfReturn(Request.Builder request) {
    OkHttpClient client = getUnsafeOkHttpClient().newBuilder().build();
    try {
        Response response = client.newCall(request.build()).execute();
        String body = response.body().string();
        StringUtils.HaoLog("body=" + body);
        HttpAfReturn httpReturn = new Gson().fromJson(body, HttpAfReturn.class);
        StringUtils.HaoLog("getJhttpAfReturn");
        StringUtils.HaoLog(response.header("url") + " " + httpReturn.success + " " + httpReturn.data);
        StringUtils.HaoLog("getJhttpAfReturn end");
        return httpReturn;
    } catch (IOException | JsonSyntaxException e) {
        e.printStackTrace();
    }
    return new HttpAfReturn();
}


HttpReturn gethttpReturn(Request.Builder request) {
    OkHttpClient client = getUnsafeOkHttpClient().newBuilder().build();
    try {
        Response response = client.newCall(request.build()).execute();
        if (response.code() == 200) {
            String body = response.body().string();
            StringUtils.HaoLog("body=" + body);
            HttpReturn httpReturn = new Gson().fromJson(body, HttpReturn.class);
            if (httpReturn != null) {
                StringUtils.HaoLog(response.request().url().toString(), httpReturn);
                return httpReturn;
            } else
                StringUtils.HaoLog(response.request().url() + " " + response.code() + " body=" + body);
        }
    } catch (IOException | IllegalStateException e) {
        StringUtils.HaoLog("gethttpReturn error=" + request + " " + e.toString());
        e.printStackTrace();
    }
    return new HttpReturn();
}
==================================================================================
Android清除WebView缓存

    public void clearCach(){
        try {
            if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP){
                CookieManager.getInstance().removeAllCookies(null);
            } else {
                CookieSyncManager.createInstance(getApplicationContext());
                CookieManager.getInstance().removeAllCookie();
                CookieSyncManager.getInstance().sync();
            }
            new WebView(getApplicationContext()).clearCache(true);
            File cacheFile = new File(getCacheDir().getParent() + "/app_webview");
            clearCacheFolder(cacheFile,System.currentTimeMillis());
            StringUtils.HaoLog("clearCach= "+System.currentTimeMillis());
        }catch (Exception e){
            e.printStackTrace();
        }
    }

    public static int clearCacheFolder(File dir, long time){
        int deletedFiles = 0;
        if(dir != null && dir.isDirectory()){
            try {
                for(File child : dir.listFiles()){
                    if(child.isDirectory()){
                        deletedFiles +=  clearCacheFolder(child, time);
                    }
                    if(child.lastModified() < time){
                        if(child.delete()){
                            deletedFiles++;
                        }
                    }
                }
            }catch (Exception e){
                e.printStackTrace();
            }
        }
        return deletedFiles;
    }

==================================================================================

儲存String到 緩存路徑 getCacheDir().getAbsolutePath()：

    public static void saveWebViewVersion(String data, Context context) {
        String fileName = "webViewVersion.txt";
        String filePath = context.getCacheDir().getAbsolutePath() + File.separator + fileName;
        try {
            File file = new File(filePath);
            FileOutputStream fos = new FileOutputStream(file);
            fos.write(data.getBytes());
            fos.close();
            StringUtils.HaoLog("文件保存成功");
        } catch (IOException e) {
            e.printStackTrace();
            StringUtils.HaoLog("保存文件失敗"+e);
        }
    }

讀取txt檔案回傳String
    public static String readTextFromFile(Context context) {
        String fileName = "webViewVersion.txt";
        String filePath = context.getCacheDir().getAbsolutePath() + File.separator + fileName;
        StringBuilder stringBuilder = new StringBuilder();
        try {
            File file = new File(filePath);
            FileInputStream fis = new FileInputStream(file);
            InputStreamReader isr = new InputStreamReader(fis);
            BufferedReader bufferedReader = new BufferedReader(isr);
            String line;
            while ((line = bufferedReader.readLine()) != null) {
                stringBuilder.append(line);
            }
            bufferedReader.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return stringBuilder.toString();
    }


==================================================================================

    public void getWebVersion() {
        new Thread(() -> {
            try {
                URL url = new URL(getMainWebURL(false));
                Document doc = Jsoup.parse(url, 3000);
                Element bodyElement = doc.body();
                String bodyContent = bodyElement.text();
                //取得版號，存到cash目錄下txt檔
                String fileName = "webViewVersion.txt";
                //String filePath = getCacheDir().getAbsolutePath() + File.separator + fileName;
                String tableOfContents = Environment.DIRECTORY_PICTURES + File.separator + "Lale 企業" + File.separator + fileName;
                File file = new File(tableOfContents);
                if(file.exists()){
                    //如果存在判斷檔案內版本是否不同，如果為true，則存檔以及清除cash
                    String oldVersion = FileUtils.readTextFromFile(file);
                    if(!oldVersion.equals(bodyContent)){
                        FileUtils.saveWebViewVersion(MainWebActivity.this, bodyContent);
                        cleanWebviewCache();
                    }
                } else {
                    //如果不存在表示為第一次使用app，則存檔以及清除cash
                    FileUtils.saveWebViewVersion(MainWebActivity.this, bodyContent);
                    cleanWebviewCache();
                }
            }catch (IOException e){
                e.printStackTrace();
            }
        }).start();
    }

==================================================================================

URL 轉  Bitmap：

public static Bitmap getBitmapFromURL(String imageUrl) {
    try {
        URL url = new URL(imageUrl);
        HttpURLConnection connection = (HttpURLConnection) url.openConnection();
        connection.setDoInput(true);
        connection.connect();
        InputStream input = connection.getInputStream();
        Bitmap bitmap = BitmapFactory.decodeStream(input);
        return bitmap;
    } catch (Exception e) {
        e.printStackTrace();
        return null;
    }
}
==================================================================================

影片縮圖，回傳 Bitmap物件，回傳就能呼叫resizeAndConvertToBase64()方法做縮圖

public static Bitmap getVideoThumbnail(String videoPath) {
    Bitmap thumbnail = null;
    try {
        MediaMetadataRetriever retriever = new MediaMetadataRetriever();
        retriever.setDataSource(videoPath);
        int width = Integer.parseInt(retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_VIDEO_WIDTH));
        int height = Integer.parseInt(retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_VIDEO_HEIGHT));
        // 獲取第一幀圖像
        thumbnail = retriever.getFrameAtTime(0, MediaMetadataRetriever.OPTION_CLOSEST);
        if (thumbnail != null) {
            // 按照指定的寬高進行縮放
            thumbnail = Bitmap.createScaledBitmap(thumbnail, width, height, false);
        }
        retriever.release();
    } catch (Exception e) {}
    return thumbnail;
}

==================================================================================

MediaMetadataRetriever retriever = new MediaMetadataRetriever();
retriever.setDataSource(file.getPath());
String width = retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_VIDEO_WIDTH);
String height = retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_VIDEO_HEIGHT);

if(".jpg".equals(fileType(file.getName()))){
  String pic = ThumbnailUtils.resizeAndConvertToBase64(file.getPath(),50);
  jsonObject.put("thumbnail",pic);
} else {
  Bitmap originalBitmap = ThumbnailUtils.getVideoThumbnail(file.getPath());
  String pic = ThumbnailUtils.resizeAndConvertToBase64(originalBitmap,50);
  jsonObject.put("thumbnail",pic);
}

==================================================================================

Build.VERSION.SDK_INT  →  是一個表示設備當前 Android 版本的整數值。 29
Build.VERSION_CODES.LOLLIPOP  →  是一個表示 Android  21版本的整數常量。 


==================================================================================
firebase 推播 棄用之替代寫法，FirebaseMessaging

FirebaseMessaging.getInstance().getToken().addOnSuccessListener(new OnSuccessListener<String>() {
    @Override
    public void onSuccess(String s) {         
    }
});


FirebaseMessaging.getInstance().getToken().addOnSuccessListener(deviceToken -> {
            if (!TextUtils.isEmpty(deviceToken)) {
                SharedPreferences pref = PreferenceManager.getDefaultSharedPreferences(AllData.context);
                new Thread(() -> {
                    HttpReturn pu;
                    try {
                        JSONObject UserIds = new JSONObject(pref.getString("UserIds", "{}"));
                        StringUtils.HaoLog("UserIds= " + UserIds);
                        StringUtils.HaoLog("deviceToken= " + deviceToken);

                        if (UserIds.length() <= 1){
                            String userId = UserControlCenter.getUserMinInfo().userId;
                            String uuid = Settings.Secure.getString(activity.getContentResolver(), Settings.Secure.ANDROID_ID);
                            String customerProperties = HashMapToJson(userId,AllData.getMainServer(),false, "");
                            pu = CloudUtils.iCloudUtils.setPusher(userId, deviceToken, uuid, customerProperties);
                        } else {
                            String userId = UserControlCenter.getUserMinInfo().userId;
                            String uuid = Settings.Secure.getString(activity.getContentResolver(), Settings.Secure.ANDROID_ID);
                            UserControlCenter.switchAccounts(userId);
                            pu = CloudUtils.iCloudUtils.updatePusher(userId, uuid);
                        }
                        StringUtils.HaoLog("setPusher=" + pu);

                    } catch (JSONException e) {
                        e.printStackTrace();
                    }
                    activity.runOnUiThread(() -> {
                        activity.finish();
                    });
                }).start();
            }
        });

==================================================================================

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="44dp"
                android:layout_marginLeft="42dp"
                android:layout_marginRight="42dp"
                android:layout_marginBottom="15dp"
                android:focusable="true"
                android:focusableInTouchMode="true"
                android:orientation="horizontal">

屬性介紹：
android:focusable="true"

用於指定視圖是否可以獲得焦點。
當您將 android:focusable 屬性設置為 true 時，表示該視圖可以獲得焦點。焦點是指當使用者與應用程序交互時，
應用程序中的視圖元素可以接收和處理使用者輸入的能力。

以下是一些常見的用法和注意事項：
使用者交互：當一個視圖可以獲得焦點時，使用者可以通過點擊、觸摸或其他交互方式將焦點設置到該視圖上。
例如，EditText 預設是可以獲得焦點的，用戶可以點擊 EditText 並開始輸入文本。
鍵盤焦點：當視圖獲得焦點時，系統會將鍵盤焦點設置到該視圖上，這意味著用戶可以通過鍵盤進行相應的操作，
例如輸入文本或使用方向鍵進行導航。
聚焦順序：如果多個視圖都可以獲得焦點，則根據聚焦順序，系統將在這些視圖之間進行焦點切換。
您可以使用 android:nextFocusUp、android:nextFocusDown、android:nextFocusLeft、android:nextFocusRight 
等屬性來指定焦點切換的順序。

請注意以下幾點：
預設情況下，大多數視圖（如 Button、EditText 等）都可以獲得焦點，但某些視圖（如 TextView）可能不具備焦點能力，
除非您明確將 android:focusable 設置為 true。
如果一個視圖的父級視圖（例如 LinearLayout）具有 android:focusable="true" 的屬性，則該視圖也將繼承父級視圖的焦點能力，
即使該視圖本身沒有明確設置 android:focusable 屬性。
您可以使用 android:focusableInTouchMode 屬性來指定視圖是否可以在觸摸模式下獲得焦點。
總之，android:focusable="true" 屬性用於指定視

==================================================================================

如何設計一個具有仰角效果的按鈕
https://stackoverflow.com/questions/63895028/how-to-design-a-button-with-elevation-effect

==================================================================================

public static String NowTime(){
    long timestamp = System.currentTimeMillis();
    Date date = new Date(timestamp);
    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
    String dateString = sdf.format(date);
    return dateString;
}

==================================================================================

            @Override
            public void onPermissionRequest(final PermissionRequest request) {
                String[]  PermissionRequest=request.getResources();
                for (int i = 0; i < PermissionRequest.length; i++) {
                    StringUtils.HaoLog("onPermissionRequest:"+PermissionRequest[i]);
                    if(PermissionRequest[i].equals("android.webkit.resource.AUDIO_CAPTURE")) {
                        if(PermissionUtils.checkPermission(MainWebActivity.this,"android.permission.RECORD_AUDIO")){
                            
                        } else {
                            runOnUiThread(()->{
                                requestPermissions(new String[]{"android.permission.RECORD_AUDIO"}, 466);
                            });
                        }
                    }
                }
                request.grant(request.getResources());
            }

==================================================================================

版本號更新：
大版號.中版號.小板號.小小板號
每次小改版都會習慣改小小板號，如果小小板號已經到9
一定要進位，例如：
1.1.3.9，下次就是 1.1.4.0
因為判斷版本更新需要同位數

==================================================================================

private void wvGoBack() {
    StringUtils.HaoLog("wvGoBack= 已經進來 "+needBack);
    if(webView.canGoBack()) {
        webView.goBack();
        StringUtils.HaoLog("wvGoBack= 成功返回上一頁 "+webView.canGoBack());
    } else {
        StringUtils.HaoLog("wvGoBack= 沒有上一頁，無法返回 "+webView.canGoBack());
    }
}

==================================================================================

        if (requestCode == DefinedUtils.REQUEST_IMAGE_PICKER) {
            ArrayList<Media> images = data.getParcelableArrayListExtra(PickerConfig.EXTRA_RESULT);
            if (images == null) {
                return;
            }
            int imageSize = images.size();
            Uri[] uris = new Uri[imageSize];
            File[] files = new File[imageSize];
            for (int i = 0; i < imageSize; i++) {
                Media media = images.get(i);
                File picture = new File(media.path);
                uris[i] = Uri.fromFile(picture);
                files[i] = picture;
            }
            if (!DefinedUtils.roomId.isEmpty()) {
                // sendFileInfo 通知選擇結果
                sendFileInfo(files);
                // sendFile 逐筆回傳上傳結果
                recursiveUpload(DefinedUtils.roomId, files, 0);
                // 假的 Uri 陣列以滿足 ValueCallback
                uris = new Uri[0];
            }

            if (mUploadMessage != null) {
                mUploadMessage.onReceiveValue(uris);
                mUploadMessage = null;
            }
        }

if (index >= files.length) {
    // 所有檔案都已經上傳完成，結束遞迴，清除 roomId
    DefinedUtils.roomId = "";
    return;
}

==================================================================================

    public static void HaoLog(String data, int showC) {
        StackTraceElement[] stes = Thread.currentThread().getStackTrace();

        // 確保showC不超過stes的長度
        showC = Math.min(showC, stes.length - 1);

        // 忽略 "MainAppCompatActivity.java" 和 "MessageBaseActivity.java" 的訊息
        while (showC < stes.length &&
                (stes[showC].getFileName().equals("MainAppCompatActivity.java") ||
                        stes[showC].getFileName().equals("MessageBaseActivity.java"))) {
            showC++;
        }

        if (showC < stes.length) {
            String tag = "HaoLog (" + stes[showC].getFileName() + ":" + stes[showC].getLineNumber() + ") ";
            tag += stes[showC].getMethodName() + " Thread=" + Thread.currentThread().getName() + "　 ";

            // 數據為null的情況
            if (data == null) {
                Log.d(tag, "null");
            }
            // 數據長度超過最大限制的情況
            else if (data.length() > MAX_LOG) {
                // 將數據分段輸出
                int startIndex = 0;
                while (startIndex < data.length()) {
                    int endIndex = Math.min(startIndex + MAX_LOG, data.length());
                    Log.d(tag, data.substring(startIndex, endIndex));
                    startIndex = endIndex;
                }
            } else {
                // 正常輸出數據的情況
                Log.d(tag, data);
            }
        }
    }

在這個修改中，我們做了幾項主要的變更：

簡化了對showC值的檢查。透過Math.min來確保showC不會超過stes的長度。
使用一個while迴圈來忽略MainAppCompatActivity.java和MessageBaseActivity.java的訊息，這使得你能夠忽略更多的檔案，只需要在迴圈中添加額外的條件。
在處理長數據的地方，使用了一個更簡單的while迴圈來分段輸出數據，而不是像原來那樣需要重複相同的程式碼來處理長度剛好是MAX_LOG倍數和不是MAX_LOG倍數的兩種情況。
這些改進都是基於讓程式碼更容易讀取和理解的目標，同時也保持了原來的功能不變。

==================================================================================

    public static boolean version(String appVersion, String dbVersion) {
        String[] appVersionParts = appVersion.split("\\.");
        String[] dbVersionParts = dbVersion.split("\\.");
        int length = Math.min(appVersionParts.length, dbVersionParts.length);
        for (int i = 0; i < length; i++) {
            int appPart = Integer.parseInt(appVersionParts[i]);
            int dbPart = Integer.parseInt(dbVersionParts[i]);
            if (dbPart > appPart) {
                return true;
            } else if (dbPart < appPart) {
                return false;
            }
        }
        if (dbVersionParts.length > appVersionParts.length) {
            return true;
        }
        return false;
    }

Boolean appVersionInt = StringUtils.version(appVersion,dbVersion.version);

這個方法首先將版本號拆分為各個部分，然後從左至右比較各部分。如果某部分的dbVersion大於appVersion，則立即返回true。
如果某部分的dbVersion小於appVersion，則立即返回false。如果所有部分都相等，那麼具有更多部分的版本被視為更大的版本。

==================================================================================
DownloadManager 下載檔案

if (cursor.moveToFirst()) {
    int statusIndex = cursor.getColumnIndex(DownloadManager.COLUMN_STATUS);
    int status = cursor.getInt(statusIndex);
    if (status == DownloadManager.STATUS_FAILED) {
        int reasonIndex = cursor.getColumnIndex(DownloadManager.COLUMN_REASON);
        int reason = cursor.getInt(reasonIndex);
    }
}
cursor.close();

==================================================================================
使用okhttp get方法下載檔案
https://blog.csdn.net/u014361280/article/details/130729619

private void judgmentFileName(JSONObject data, ActionType type)

void getFile(String url, String fileName);


    public void getFile(String url,String fileName) {
        Request.Builder request = new Request.Builder()
                .url(url)
                .get();
        OkHttpClient client = getUnsafeOkHttpClient().newBuilder().build();
        client.newCall(request.build()).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                e.printStackTrace();
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                if (!response.isSuccessful()) {
                    throw new IOException("Unexpected code " + response);
                } else {
                    try{
                        InputStream inputStream = response.body().byteStream();
                        File downloadsDir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS);
                        File outFile = new File(downloadsDir, fileName);
                        OutputStream out = new FileOutputStream(outFile);
                        byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];
                        int len;
                        while ((len = inputStream.read(buffer)) != -1) {
                            out.write(buffer, 0, len);
                        }
                        out.close();
                        inputStream.close();
                    } catch (FileNotFoundException e) {
                        StringUtils.HaoLog("無法打開閱讀 " + e);
                    } catch (IOException e) {
                        StringUtils.HaoLog("無法打開閱讀 " + e);
                        e.printStackTrace();
                    }
                }
            }
        });
    }

CloudUtils.iCloudUtils.getFile(data.optString("url"), null);
CloudUtils.iCloudUtils.getFile(data.optString("url"), data.optString("fileName"));

==================================================================================
系统顯示大小設置
系统顯示字體大小設置
    DisplayMetrics displayMetrics = new DisplayMetrics();
    getWindowManager().getDefaultDisplay().getMetrics(displayMetrics);
    int height = displayMetrics.heightPixels;
    int width = displayMetrics.widthPixels;


    Configuration configuration = getResources().getConfiguration();
    float fontScale = configuration.fontScale;
    int densityDpi = configuration.densityDpi;

    StringUtils.HaoLog("dddd= "+height);
    StringUtils.HaoLog("dddd= "+width);

==================================================================================

CommonUtils.showToast(MainWebActivity.this,getLayoutInflater(),message,false);

==================================================================================

long downloadId = dm.enqueue(request);
// 建立一個查詢物件
DownloadManager.Query query = new DownloadManager.Query();
// 將你的下載ID加入到查詢中
query.setFilterById(downloadId);
Cursor cursor = dm.query(query);
    try {
        if (cursor.moveToFirst()) {
            int columnIndex = cursor.getColumnIndex(DownloadManager.COLUMN_STATUS);
            // 取得下載狀態
            int status = cursor.getInt(columnIndex);
            switch (status) {
                case DownloadManager.STATUS_SUCCESSFUL:
                    // 下載成功
                    sendToWeb(new JSONObject().put("type", "downloadFile").put("data", new JSONObject().put("isSuccess", true)).toString());
                    break;
                case DownloadManager.STATUS_FAILED:
                    // 下載失敗
                    sendToWeb(new JSONObject().put("type", "downloadFile").put("data", new JSONObject().put("isSuccess", false)).toString());
                    break;
            }
        }
    } catch (JSONException | NullPointerException e) {
        e.printStackTrace();
    }

==================================================================================

外部分享阻擋svg：

List<String> acceptedMimeTypes = specificExtension();
boolean support = !acceptedMimeTypes.contains(getIntent().getType());
if(support){
    LocalBroadcastManager.getInstance(this).sendBroadcast(intent1); //發送廣播訊息
    startActivity(intent);
} else {
    CommonUtils.showToast(shareActivity.this,getLayoutInflater(),"檔案類型不支援",false);
}

private List<String> specificExtension(){
    List<String> acceptedMimeTypes = Arrays.asList("image/svg+xml");
    return acceptedMimeTypes;
}

==================================================================================

動態設定app當前執行語言的方法
http://fishtsaii91.blogspot.com/2018/03/android-studio-android-app-app.html
https://thumbb13555.pixnet.net/blog/post/333199480-supportdifferentlanguages
https://hackmd.io/@YingChiao/Hy9zH54WH
https://github.com/hgncxzy/MultiLanguageSwitch/tree/master
https://www.itread01.com/article/1489292421.html


public static void setLocaleForMainAppCompat(Context context, String languageCode) {
    Resources res = context.getResources();
    Configuration config = new Configuration(res.getConfiguration());
    Locale newLocale;
    String delimiter = languageCode.contains("_") ? "_" : "-";
    String[] langCountry = languageCode.split(delimiter);
    if (langCountry.length == 2) {
        newLocale = new Locale(langCountry[0], langCountry[1]);
    } else {
        newLocale = new Locale(languageCode);
    }
    config.setLocale(newLocale);
    context.createConfigurationContext(config);
    res.updateConfiguration(config, res.getDisplayMetrics());
}


==================================================================================


快報 scheme 設置，設置在MAIN

<intent-filter android:autoVerify="true">
    <action android:name="android.intent.action.VIEW" />
    <category android:name="android.intent.category.DEFAULT" />
    <category android:name="android.intent.category.BROWSABLE" />

    <data
        android:scheme="https"
        android:host="news.lale.im" />
</intent-filter>

String url = "https://news.lale.im/_news/article/" + artId + "?token=$token";
AsynNetUtils.NewsPOST


Intent intent2 = getIntent(); 
Uri data = intent2.getData();
if(data != null){
    String scheme = data.getScheme();
    String host = data.getHost();
    String path = data.getPath();
    String query = data.getQuery();
    StringUtils.HaoLog("testWebActivity BroadcastReceiver " + data);
    StringUtils.HaoLog("testWebActivity BroadcastReceiver " + path);
}


android.intent.action.SEND
image/jpeg

android.intent.action.VIEW
==================================================================================

在專案內引用 jitsi-meet 套件

allprojects {
    repositories {
        google()
        jcenter()
        maven {
            url "https://repo.eclipse.org/content/repositories/paho-snapshots/"
        }
        maven {
            url "https://github.com/jitsi/jitsi-maven-repository/raw/master/releases"
        }
    }
}

/************* jitsi **************/
implementation ('org.jitsi.react:jitsi-meet-sdk:2.8.2') { transitive = true }

==================================================================================


JSONArray settingsArray = new JSONArray();
JSONObject screenshotSetting = new JSONObject();
JSONObject downloadSetting = new JSONObject();
JSONObject fileExtSetting = new JSONObject();
JSONObject watermarkSetting = new JSONObject();
    try {
        screenshotSetting.put("settingKey", "screenshot_forbidden");
        screenshotSetting.put("settingValue", "false");
        screenshotSetting.put("additionalValue", "");
        settingsArray.put(screenshotSetting);

        downloadSetting.put("settingKey", "download_forbidden");
        downloadSetting.put("settingValue", "false");
        downloadSetting.put("additionalValue", "");
        settingsArray.put(downloadSetting);

        fileExtSetting.put("settingKey", "restrict_file_ext");
        fileExtSetting.put("settingValue", "false");
        fileExtSetting.put("additionalValue", "");
        settingsArray.put(fileExtSetting);

        watermarkSetting.put("settingKey", "download_watermark");
        watermarkSetting.put("settingValue", "false");
        watermarkSetting.put("additionalValue", "");
        settingsArray.put(watermarkSetting);

    } catch (JSONException e){
        e.printStackTrace();
    }

====================================================================================================

要取得設備的IPv4和IPv6位址，你需要檢索不同網路介面上的這些位址：

public static void getIpAddresses(Context context) {
    try {
        Enumeration<NetworkInterface> networkInterfaces = NetworkInterface.getNetworkInterfaces();
        while (networkInterfaces.hasMoreElements()) {
            NetworkInterface networkInterface = networkInterfaces.nextElement();
            Enumeration<InetAddress> inetAddresses = networkInterface.getInetAddresses();
            while (inetAddresses.hasMoreElements()) {
                InetAddress inetAddress = inetAddresses.nextElement();
                if (!inetAddress.isLoopbackAddress()) {
                    if (inetAddress instanceof Inet6Address) {
                        StringUtils.HaoLog("ddd= IPv6 Address " + inetAddress.getHostAddress());
                    } else {
                        StringUtils.HaoLog("ddd= IPv4 Address " + inetAddress.getHostAddress());
                    }
                }
            }
        }
    } catch (Exception e) {
            e.printStackTrace();
    }
}


取得設備的本機 IP 位址，取得的ip為 IPv4：

private static String getLocalIpAddress(Context context) {
    WifiManager wifiManager = (WifiManager) context.getSystemService(Context.WIFI_SERVICE);
    if (wifiManager != null) {
         WifiInfo wifiInfo = wifiManager.getConnectionInfo();
        int ipAddress = wifiInfo.getIpAddress();

        // 格式化 IP 地址
        String ip = String.format("%d.%d.%d.%d",
                (ipAddress & 0xff),
                (ipAddress >> 8 & 0xff),
                (ipAddress >> 16 & 0xff),
                (ipAddress >> 24 & 0xff));

        return ip;
    } else {
        StringUtils.HaoLog("ddd= "+"WifiManager is null");
        return null;
    }
}

====================================================================================================

private static Bitmap calculateImageReductionRatio(Bitmap bitmap, int bitmapWidth, int canvasWidth, int bitmapHeight, int canvasHeight){
    // 計算寬度和高度的比率
    float widthRatio = (float) canvasWidth / (float) bitmapWidth;
    float heightRatio = (float) canvasHeight / (float) bitmapHeight;
    // 使用較小的比率來縮小影像
    float scale = Math.min(widthRatio, heightRatio) * 0.8f;
    // 設定圖片縮放比例
    Matrix matrix = new Matrix();
    matrix.postScale(scale, scale);

    // 使用Matrix物件對Bitmap進行縮放
    bitmap = Bitmap.createBitmap(bitmap, 0, 0, bitmapWidth, bitmapHeight, matrix, true);
    return bitmap;
}

====================================================================================================

okhttp 執行網路請求 get拿到 Bitmap 物件

@Override
    public Bitmap urlToBitmap(String imageUrl) {
        Request.Builder request = new Request.Builder()
                .url(imageUrl)
                .get();

        OkHttpClient client = getUnsafeOkHttpClient().newBuilder()
                .connectTimeout(15, TimeUnit.SECONDS)
                .writeTimeout(15, TimeUnit.SECONDS)
                .readTimeout(15, TimeUnit.SECONDS)
                .build();

        try {
            Response response = client.newCall(request.build()).execute();
            if(response.code() == 200){
                ResponseBody responseBody = response.body();
                InputStream input = responseBody.byteStream();
                Bitmap bitmap = BitmapFactory.decodeStream(input);
                input.close();
                return bitmap;
            }
        } catch (IOException | JsonSyntaxException e){
            e.printStackTrace();
        }
        return null;
    }

====================================================================================================


// 獲取水印文字的寬度和高度
float textWidth = paint.measureText(labels.get(0));
float textHeight = paint.getTextSize();
// 計算文字的左上角位置，使它們都位於畫布中心
int textLeft = (canvasWidth - (int)textWidth) / 2;
int textTop = (canvasHeight + (int)textHeight) / 2;

// rotate 方法將整個畫布旋轉指定的角度（degress），以下改成旋轉文字角度
canvas.rotate(-degress, textLeft + textWidth / 2, textTop - textHeight / 2);

這段程式邏輯

1. float textWidth = paint.measureText(labels.get(0));：這一行程式碼使用 paint 物件的 measureText 方法來測量水印文字 labels 中的第一個元素的寬度，並將結果存儲在 textWidth 中。

2. float textHeight = paint.getTextSize();：這一行程式碼使用 paint 物件的 getTextSize 方法來獲取設置的文字大小，並將結果存儲在 textHeight 中。

3. int textLeft = (canvasWidth - (int)textWidth) / 2;：這一行程式碼計算了水印文字的左上角的 x 座標，使文字位於畫布水平中心。它減去文字寬度的一半，以確保文字水平居中。

4. int textTop = (canvasHeight + (int)textHeight) / 2;：這一行程式碼計算了水印文字的左上角的 y 座標，使文字位於畫布垂直中心。它將文字高度的一半添加到畫布高度的一半，以確保文字垂直居中。

5. canvas.rotate(-degress, textLeft + textWidth / 2, textTop - textHeight / 2);：這一行程式碼使用 canvas 的 rotate 方法來旋轉畫布，以改變水印文字的角度。-degress 是旋轉的角度，並且旋轉中心點是 textLeft + textWidth / 2（文字中心的 x 座標）和 textTop - textHeight / 2（文字中心的 y 座標）。這樣，水印文字將以指定的角度旋轉，使其擺放在畫布中心。

====================================================================================================

做一個三個按鈕的訊息框，按鈕可以隨意更改數量(1~3個按鈕)


public static void showDialogWebMessage(Context context, String title, List<String> buttons, List<CallbackUtils.noReturn> callbacks) {
        runOnUiThread(() -> {
            AlertDialog.Builder builder = new AlertDialog.Builder(context)
                    .setTitle(title);

            List<String> translatedButtons = new ArrayList<>();
            for (String button : buttons) {
                String translatedButton = translateButton(button);
                translatedButtons.add(translatedButton);
            }

            if (translatedButtons.size() > 0) {
                builder.setPositiveButton(translatedButtons.get(0), (dialog, which) -> {
                    dialog.dismiss();
                    callbacks.get(0).Callback();
                });
            }

            if (translatedButtons.size() > 1) {
                builder.setNegativeButton(translatedButtons.get(1), (dialog, which) -> {
                    dialog.dismiss();
                    callbacks.get(1).Callback();
                });
            }

            if (translatedButtons.size() > 2) {
                builder.setNeutralButton(translatedButtons.get(2), (dialog, which) -> {
                    dialog.dismiss();
                    callbacks.get(2).Callback();
                });
            }
            builder.setCancelable(false).create().show();
        });
    }


private static String translateButton(String button) {
        switch (button) {
            case "logout":
                return "登出";
            case "ok":
                return "確定";
            default:
                return button;
        }
    }

====================================================================================================


private void showDialog(){
    List<String> buttons = new ArrayList<>();
    buttons.add("1");
    buttons.add("2");
    buttons.add("3");

    List<CallbackUtils.noReturn> callbacks = new ArrayList<>();
    for (int i = 0; i < buttons.size(); i++) {
        final int buttonIndex = i;
        CallbackUtils.noReturn callback = new CallbackUtils.noReturn() {
            @Override
            public void Callback() {
                String button = buttons.get(buttonIndex);
                StringUtils.HaoLog("ddd= " + button);
            }
        };
        callbacks.add(callback);
    }
    DialogUtils.showCustomizedDialog(MainWebActivity.this,"標題1","內容2",buttons,callbacks);
}

====================================================================================================

const postToApp = (command) => {
  if (isIOS) {
    window.webkit.messageHandlers.laleIm.postMessage(JSON.stringify("{\"command\":\"closeWeb\"}"))
  } else {
    window.laleIm.postMessage(JSON.stringify("{\"command\":\"closeWeb\"}"))
  }
}

====================================================================================================
取得當前的 activity：

public boolean isAppInForeground() {
    ActivityManager activityManager = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);
    List<ActivityManager.RunningTaskInfo> tasks = activityManager.getRunningTasks(1);

    if (tasks.size() > 0) {
        ComponentName topActivity = tasks.get(0).topActivity;
        if (topActivity.getPackageName().equals(context.getPackageName())) {
            // 應用程序處於前台
            return true;
        }
    }

    return false;
}

public boolean isMainActivityInForeground() {
    ActivityManager activityManager = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);
    List<ActivityManager.RunningTaskInfo> tasks = activityManager.getRunningTasks(1);

    if (tasks.size() > 0) {
        ComponentName topActivity = tasks.get(0).topActivity;
        if (topActivity.getClassName().equals("com.example.MainActivity")) {
            // MainActivity處於前台
            return true;
        }
    }

    return false;
}

或是更簡單的方法：
public static  String page = "";

@Override
protected void onResume() {
    super.onResume();
    page = this.getClass().getName();
}

if(MainAppCompatActivity.page.equals(WebJitisiMeetActivity.class.getName()))

====================================================================================================


public static void runOnUiThread(Runnable runnable, long delayInMs) {
    Class var3 = UiThreadUtil.class;
    synchronized (UiThreadUtil.class) {
        if (sMainHandler == null) {
            sMainHandler = new Handler(Looper.getMainLooper());
        }
    }
    sMainHandler.postDelayed(runnable, delayInMs);
}

1.方法定義：public static void runOnUiThread(Runnable runnable, long delayInMs) - 這是一個公共靜態方法，接受一個 Runnable 對象和一個延遲時間（毫秒）作為參數。

2.同步區塊：使用 synchronized (UiThreadUtil.class) 確保同時只有一個線程可以執行同步塊內的代碼。這是為了避免在多線程環境中同時創建多個 Handler 實例。

3.檢查並創建 Handler：代碼首先檢查靜態變量 sMainHandler 是否為 null。如果是，則創建一個新的 Handler 關聯到主UI線程的消息循環器（Looper.getMainLooper()）。這樣做是為了確保接下來的操作都在主UI線程上執行。

4.延遲執行 Runnable：使用 sMainHandler.postDelayed(runnable, delayInMs) 將傳入的 Runnable 對象安排在指定的延遲後執行。這個 Runnable 將在主UI線程上執行，這對於更新UI或進行其他需要在主線程上執行的操作是必要的。

總結來說，這段代碼的目的是提供一種安全的方式來在主UI線程上延遲執行任務，同時確保 Handler 的創建是線程安全的。這在Android開發中是一個常見的模式，用於從後台線程切換到主線程，尤其是當需要更新UI或進行其他與UI相關的操作時。



====================================================================================================

取得 nowUserId

UserControlCenter.getUserMinInfo().userId

StringUtils.HaoLog("fff= 1 " + UserControlCenter.getUserMinInfo().eimUserData.announceServerUrl);
StringUtils.HaoLog("fff= 2 " + AllData.getAnnouncementServer());


private static UserMin getUserMinInfoByPhone() {
    SharedPreferences pref = PreferenceManager.getDefaultSharedPreferences(AllData.context);
    String id = pref.getString("nowUserId", "");
    if (!id.isEmpty()) {
        try {
            JSONObject UserIds = new JSONObject(pref.getString("UserIds", "[]"));
            Gson gson = new Gson();
            StringUtils.HaoLog(UserIds.getString(id));
            return gson.fromJson(UserIds.getString(id), UserMin.class);
        } catch (JSONException e) {
            e.printStackTrace();
        }
    }
    return null;
}


====================================================================================================

View 取得鍵盤高度

public void close_Input_Board(View view) {
    InputMethodManager imm = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);
    imm.hideSoftInputFromWindow(findViewById(R.id.toolbar_layout).getWindowToken(), 0);
    view.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
        @Override
        public void onGlobalLayout() {
            Rect rect = new Rect();
            view.getWindowVisibleDisplayFrame(rect);
            // 獲取屏幕的高度
            int screenHeight = view.getRootView().getHeight();
            // 計算差值
            int keypadHeight = screenHeight - rect.bottom;
        }
    });
}


edit_account.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View view) {
        view.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
            @Override
            public void onGlobalLayout() {
                Rect rect = new Rect();
                view.getWindowVisibleDisplayFrame(rect);
                // 獲取屏幕的高度
                int screenHeight = view.getRootView().getHeight();
                StringUtils.HaoLog("fff= " + screenHeight);
                // 計算差值
                int keypadHeight = screenHeight - rect.bottom;
            }
        });
    }
});
====================================================================================================

public void updateNotification(int unreadCount) {
    NotificationManager notificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);

    Notification notification = new NotificationCompat.Builder(this, "lale_channel_id")
        .setContentTitle("您有新消息")
        .setContentText("未讀消息數量: " + unreadCount)
        .setSmallIcon(R.drawable.lale_logo)
        .setNumber(unreadCount) // 設置未讀數字
        .build();

// 使用相同的 ID 發送通知，以更新現有通知
    notificationManager.notify(1, notification);
}

====================================================================================================



